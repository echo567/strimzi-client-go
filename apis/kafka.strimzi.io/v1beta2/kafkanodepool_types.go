// Code generated by schema-generate. DO NOT EDIT.

package v1beta2

import (
    "bytes"
    "errors"
    "encoding/json"
)

// Affinity The pod's affinity rules.
type Affinity struct {
  NodeAffinity *NodeAffinity `json:"nodeAffinity,omitempty"`
  PodAffinity *PodAffinity `json:"podAffinity,omitempty"`
  PodAntiAffinity *PodAntiAffinity `json:"podAntiAffinity,omitempty"`
}

// Annotations Annotations added to the Kubernetes resource.
type Annotations struct {
}

// Capabilities 
type Capabilities struct {
  Add []string `json:"add,omitempty"`
  Drop []string `json:"drop,omitempty"`
}

// ClaimsItems 
type ClaimsItems struct {
  Name string `json:"name,omitempty"`
}

// ConditionsItems 
type ConditionsItems struct {

  // Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
  LastTransitionTime string `json:"lastTransitionTime,omitempty"`

  // Human-readable message indicating details about the condition's last transition.
  Message string `json:"message,omitempty"`

  // The reason for the condition's last transition (a single word in CamelCase).
  Reason string `json:"reason,omitempty"`

  // The status of the condition, either True, False or Unknown.
  Status string `json:"status,omitempty"`

  // The unique identifier of a condition, used to distinguish between other conditions in the resource.
  Type string `json:"type,omitempty"`
}

// EnvItems 
type EnvItems struct {

  // The environment variable key.
  Name string `json:"name,omitempty"`

  // The environment variable value.
  Value string `json:"value,omitempty"`
}

// HostAliasesItems 
type HostAliasesItems struct {
  Hostnames []string `json:"hostnames,omitempty"`
  Ip string `json:"ip,omitempty"`
}

// ImagePullSecretsItems 
type ImagePullSecretsItems struct {
  Name string `json:"name,omitempty"`
}

// InitContainer Template for the Kafka init container.
type InitContainer struct {

  // Environment variables which should be applied to the container.
  Env []*EnvItems `json:"env,omitempty"`

  // Security context for the container.
  SecurityContext *SecurityContext `json:"securityContext,omitempty"`
}

// JavaSystemPropertiesItems 
type JavaSystemPropertiesItems struct {

  // The system property name.
  Name string `json:"name,omitempty"`

  // The system property value.
  Value string `json:"value,omitempty"`
}

// JvmOptions JVM Options for pods.
type JvmOptions struct {

  // Specifies whether the Garbage Collection logging is enabled. The default is false.
  GcLoggingEnabled bool `json:"gcLoggingEnabled,omitempty"`

  // A map of additional system properties which will be passed using the `-D` option to the JVM.
  JavaSystemProperties []*JavaSystemPropertiesItems `json:"javaSystemProperties,omitempty"`

  // A map of -XX options to the JVM.
  XX *XX `json:"-XX,omitempty"`

  // -Xms option to to the JVM.
  Xms string `json:"-Xms,omitempty"`

  // -Xmx option to to the JVM.
  Xmx string `json:"-Xmx,omitempty"`
}

// KafkaContainer Template for the Kafka broker container.
type KafkaContainer struct {

  // Environment variables which should be applied to the container.
  Env []*EnvItems `json:"env,omitempty"`

  // Security context for the container.
  SecurityContext *SecurityContext `json:"securityContext,omitempty"`
}

// KafkaNodePool 
type KafkaNodePool struct {

  // The specification of the KafkaNodePool.
  Spec *Spec `json:"spec,omitempty"`

  // The status of the KafkaNodePool.
  Status *Status `json:"status,omitempty"`
}

// LabelSelector 
type LabelSelector struct {
  MatchExpressions []*MatchExpressionsItems `json:"matchExpressions,omitempty"`
  MatchLabels *MatchLabels `json:"matchLabels,omitempty"`
}

// Labels Labels added to the Kubernetes resource.
type Labels struct {
}

// Limits 
type Limits struct {
}

// MatchExpressionsItems 
type MatchExpressionsItems struct {
  Key string `json:"key,omitempty"`
  Operator string `json:"operator,omitempty"`
  Values []string `json:"values,omitempty"`
}

// MatchFieldsItems 
type MatchFieldsItems struct {
  Key string `json:"key,omitempty"`
  Operator string `json:"operator,omitempty"`
  Values []string `json:"values,omitempty"`
}

// MatchLabels 
type MatchLabels struct {
}

// Metadata Metadata applied to the resource.
type Metadata struct {

  // Annotations added to the Kubernetes resource.
  Annotations *Annotations `json:"annotations,omitempty"`

  // Labels added to the Kubernetes resource.
  Labels *Labels `json:"labels,omitempty"`
}

// NamespaceSelector 
type NamespaceSelector struct {
  MatchExpressions []*MatchExpressionsItems `json:"matchExpressions,omitempty"`
  MatchLabels *MatchLabels `json:"matchLabels,omitempty"`
}

// NodeAffinity 
type NodeAffinity struct {
  PreferredDuringSchedulingIgnoredDuringExecution []*PreferredDuringSchedulingIgnoredDuringExecutionItems `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`
  RequiredDuringSchedulingIgnoredDuringExecution *RequiredDuringSchedulingIgnoredDuringExecution `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

// NodeSelectorTermsItems 
type NodeSelectorTermsItems struct {
  MatchExpressions []*MatchExpressionsItems `json:"matchExpressions,omitempty"`
  MatchFields []*MatchFieldsItems `json:"matchFields,omitempty"`
}

// OverridesItems 
type OverridesItems struct {

  // Id of the kafka broker (broker identifier).
  Broker int `json:"broker,omitempty"`

  // The storage class to use for dynamic volume allocation for this broker.
  Class string `json:"class,omitempty"`
}

// PerPodIngress Template for Kafka per-pod `Ingress` used for access from outside of Kubernetes.
type PerPodIngress struct {

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// PerPodRoute Template for Kafka per-pod `Routes` used for access from outside of OpenShift.
type PerPodRoute struct {

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// PerPodService Template for Kafka per-pod `Services` used for access from outside of Kubernetes.
type PerPodService struct {

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// PersistentVolumeClaim Template for all Kafka `PersistentVolumeClaims`.
type PersistentVolumeClaim struct {

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// Pod Template for Kafka `Pods`.
type Pod struct {

  // The pod's affinity rules.
  Affinity *Affinity `json:"affinity,omitempty"`

  // Indicates whether information about services should be injected into Pod's environment variables.
  EnableServiceLinks bool `json:"enableServiceLinks,omitempty"`

  // The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
  HostAliases []*HostAliasesItems `json:"hostAliases,omitempty"`

  // List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
  ImagePullSecrets []*ImagePullSecretsItems `json:"imagePullSecrets,omitempty"`

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`

  // The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
  PriorityClassName string `json:"priorityClassName,omitempty"`

  // The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
  SchedulerName string `json:"schedulerName,omitempty"`

  // Configures pod-level security attributes and common container settings.
  SecurityContext *SecurityContext `json:"securityContext,omitempty"`

  // The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
  TerminationGracePeriodSeconds int `json:"terminationGracePeriodSeconds,omitempty"`

  // Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.
  TmpDirSizeLimit string `json:"tmpDirSizeLimit,omitempty"`

  // The pod's tolerations.
  Tolerations []*TolerationsItems `json:"tolerations,omitempty"`

  // The pod's topology spread constraints.
  TopologySpreadConstraints []*TopologySpreadConstraintsItems `json:"topologySpreadConstraints,omitempty"`
}

// PodAffinity 
type PodAffinity struct {
  PreferredDuringSchedulingIgnoredDuringExecution []*PreferredDuringSchedulingIgnoredDuringExecutionItems `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`
  RequiredDuringSchedulingIgnoredDuringExecution []*RequiredDuringSchedulingIgnoredDuringExecutionItems `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

// PodAffinityTerm 
type PodAffinityTerm struct {
  LabelSelector *LabelSelector `json:"labelSelector,omitempty"`
  NamespaceSelector *NamespaceSelector `json:"namespaceSelector,omitempty"`
  Namespaces []string `json:"namespaces,omitempty"`
  TopologyKey string `json:"topologyKey,omitempty"`
}

// PodAntiAffinity 
type PodAntiAffinity struct {
  PreferredDuringSchedulingIgnoredDuringExecution []*PreferredDuringSchedulingIgnoredDuringExecutionItems `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`
  RequiredDuringSchedulingIgnoredDuringExecution []*RequiredDuringSchedulingIgnoredDuringExecutionItems `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

// PodSet Template for Kafka `StrimziPodSet` resource.
type PodSet struct {

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// Preference 
type Preference struct {
  MatchExpressions []*MatchExpressionsItems `json:"matchExpressions,omitempty"`
  MatchFields []*MatchFieldsItems `json:"matchFields,omitempty"`
}

// PreferredDuringSchedulingIgnoredDuringExecutionItems 
type PreferredDuringSchedulingIgnoredDuringExecutionItems struct {
  PodAffinityTerm *PodAffinityTerm `json:"podAffinityTerm,omitempty"`
  Weight int `json:"weight,omitempty"`
}

// Requests 
type Requests struct {
}

// RequiredDuringSchedulingIgnoredDuringExecution 
type RequiredDuringSchedulingIgnoredDuringExecution struct {
  NodeSelectorTerms []*NodeSelectorTermsItems `json:"nodeSelectorTerms,omitempty"`
}

// RequiredDuringSchedulingIgnoredDuringExecutionItems 
type RequiredDuringSchedulingIgnoredDuringExecutionItems struct {
  LabelSelector *LabelSelector `json:"labelSelector,omitempty"`
  NamespaceSelector *NamespaceSelector `json:"namespaceSelector,omitempty"`
  Namespaces []string `json:"namespaces,omitempty"`
  TopologyKey string `json:"topologyKey,omitempty"`
}

// Resources CPU and memory resources to reserve.
type Resources struct {
  Claims []*ClaimsItems `json:"claims,omitempty"`
  Limits *Limits `json:"limits,omitempty"`
  Requests *Requests `json:"requests,omitempty"`
}

// SeLinuxOptions 
type SeLinuxOptions struct {
  Level string `json:"level,omitempty"`
  Role string `json:"role,omitempty"`
  Type string `json:"type,omitempty"`
  User string `json:"user,omitempty"`
}

// SeccompProfile 
type SeccompProfile struct {
  LocalhostProfile string `json:"localhostProfile,omitempty"`
  Type string `json:"type,omitempty"`
}

// SecurityContext Configures pod-level security attributes and common container settings.
type SecurityContext struct {
  FsGroup int `json:"fsGroup,omitempty"`
  FsGroupChangePolicy string `json:"fsGroupChangePolicy,omitempty"`
  RunAsGroup int `json:"runAsGroup,omitempty"`
  RunAsNonRoot bool `json:"runAsNonRoot,omitempty"`
  RunAsUser int `json:"runAsUser,omitempty"`
  SeLinuxOptions *SeLinuxOptions `json:"seLinuxOptions,omitempty"`
  SeccompProfile *SeccompProfile `json:"seccompProfile,omitempty"`
  SupplementalGroups []int `json:"supplementalGroups,omitempty"`
  Sysctls []*SysctlsItems `json:"sysctls,omitempty"`
  WindowsOptions *WindowsOptions `json:"windowsOptions,omitempty"`
}

// Selector Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
type Selector struct {
}

// Spec The specification of the KafkaNodePool.
type Spec struct {

  // JVM Options for pods.
  JvmOptions *JvmOptions `json:"jvmOptions,omitempty"`

  // The number of pods in the pool.
  Replicas int `json:"replicas"`

  // CPU and memory resources to reserve.
  Resources *Resources `json:"resources,omitempty"`

  // The roles that the nodes in this pool will have when KRaft mode is enabled. Supported values are 'broker' and 'controller'. This field is required. When KRaft mode is disabled, the only allowed value if `broker`.
  Roles []string `json:"roles"`

  // Storage configuration (disk). Cannot be updated.
  Storage *Storage `json:"storage"`

  // Template for pool resources. The template allows users to specify how the resources belonging to this pool are generated.
  Template *Template `json:"template,omitempty"`
}

// Status The status of the KafkaNodePool.
type Status struct {

  // Kafka cluster ID.
  ClusterId string `json:"clusterId,omitempty"`

  // List of status conditions.
  Conditions []*ConditionsItems `json:"conditions,omitempty"`

  // Label selector for pods providing this resource.
  LabelSelector string `json:"labelSelector,omitempty"`

  // Node IDs used by Kafka nodes in this pool.
  NodeIds []int `json:"nodeIds,omitempty"`

  // The generation of the CRD that was last reconciled by the operator.
  ObservedGeneration int `json:"observedGeneration,omitempty"`

  // The current number of pods being used to provide this resource.
  Replicas int `json:"replicas,omitempty"`
}

// Storage Storage configuration (disk). Cannot be updated.
type Storage struct {

  // The storage class to use for dynamic volume allocation.
  Class string `json:"class,omitempty"`

  // Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
  DeleteClaim bool `json:"deleteClaim,omitempty"`

  // Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
  Id int `json:"id,omitempty"`

  // Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
  Overrides []*OverridesItems `json:"overrides,omitempty"`

  // Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
  Selector *Selector `json:"selector,omitempty"`

  // When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
  Size string `json:"size,omitempty"`

  // When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
  SizeLimit string `json:"sizeLimit,omitempty"`

  // Storage type, must be either 'ephemeral', 'persistent-claim', or 'jbod'.
  Type string `json:"type"`

  // List of volumes as Storage objects representing the JBOD disks array.
  Volumes []*VolumesItems `json:"volumes,omitempty"`
}

// SysctlsItems 
type SysctlsItems struct {
  Name string `json:"name,omitempty"`
  Value string `json:"value,omitempty"`
}

// Template Template for pool resources. The template allows users to specify how the resources belonging to this pool are generated.
type Template struct {

  // Template for the Kafka init container.
  InitContainer *InitContainer `json:"initContainer,omitempty"`

  // Template for the Kafka broker container.
  KafkaContainer *KafkaContainer `json:"kafkaContainer,omitempty"`

  // Template for Kafka per-pod `Ingress` used for access from outside of Kubernetes.
  PerPodIngress *PerPodIngress `json:"perPodIngress,omitempty"`

  // Template for Kafka per-pod `Routes` used for access from outside of OpenShift.
  PerPodRoute *PerPodRoute `json:"perPodRoute,omitempty"`

  // Template for Kafka per-pod `Services` used for access from outside of Kubernetes.
  PerPodService *PerPodService `json:"perPodService,omitempty"`

  // Template for all Kafka `PersistentVolumeClaims`.
  PersistentVolumeClaim *PersistentVolumeClaim `json:"persistentVolumeClaim,omitempty"`

  // Template for Kafka `Pods`.
  Pod *Pod `json:"pod,omitempty"`

  // Template for Kafka `StrimziPodSet` resource.
  PodSet *PodSet `json:"podSet,omitempty"`
}

// TolerationsItems 
type TolerationsItems struct {
  Effect string `json:"effect,omitempty"`
  Key string `json:"key,omitempty"`
  Operator string `json:"operator,omitempty"`
  TolerationSeconds int `json:"tolerationSeconds,omitempty"`
  Value string `json:"value,omitempty"`
}

// TopologySpreadConstraintsItems 
type TopologySpreadConstraintsItems struct {
  LabelSelector *LabelSelector `json:"labelSelector,omitempty"`
  MatchLabelKeys []string `json:"matchLabelKeys,omitempty"`
  MaxSkew int `json:"maxSkew,omitempty"`
  MinDomains int `json:"minDomains,omitempty"`
  NodeAffinityPolicy string `json:"nodeAffinityPolicy,omitempty"`
  NodeTaintsPolicy string `json:"nodeTaintsPolicy,omitempty"`
  TopologyKey string `json:"topologyKey,omitempty"`
  WhenUnsatisfiable string `json:"whenUnsatisfiable,omitempty"`
}

// VolumesItems 
type VolumesItems struct {

  // The storage class to use for dynamic volume allocation.
  Class string `json:"class,omitempty"`

  // Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
  DeleteClaim bool `json:"deleteClaim,omitempty"`

  // Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
  Id int `json:"id,omitempty"`

  // Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
  Overrides []*OverridesItems `json:"overrides,omitempty"`

  // Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
  Selector *Selector `json:"selector,omitempty"`

  // When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
  Size string `json:"size,omitempty"`

  // When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
  SizeLimit string `json:"sizeLimit,omitempty"`

  // Storage type, must be either 'ephemeral' or 'persistent-claim'.
  Type string `json:"type"`
}

// WindowsOptions 
type WindowsOptions struct {
  GmsaCredentialSpec string `json:"gmsaCredentialSpec,omitempty"`
  GmsaCredentialSpecName string `json:"gmsaCredentialSpecName,omitempty"`
  HostProcess bool `json:"hostProcess,omitempty"`
  RunAsUserName string `json:"runAsUserName,omitempty"`
}

// XX A map of -XX options to the JVM.
type XX struct {
}

func (strct *Spec) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "jvmOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"jvmOptions\": ")
	if tmp, err := json.Marshal(strct.JvmOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Replicas" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "replicas" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"replicas\": ")
	if tmp, err := json.Marshal(strct.Replicas); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "resources" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"resources\": ")
	if tmp, err := json.Marshal(strct.Resources); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Roles" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "roles" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"roles\": ")
	if tmp, err := json.Marshal(strct.Roles); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Storage" field is required
    if strct.Storage == nil {
        return nil, errors.New("storage is a required field")
    }
    // Marshal the "storage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"storage\": ")
	if tmp, err := json.Marshal(strct.Storage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "template" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"template\": ")
	if tmp, err := json.Marshal(strct.Template); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Spec) UnmarshalJSON(b []byte) error {
    replicasReceived := false
    rolesReceived := false
    storageReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "jvmOptions":
            if err := json.Unmarshal([]byte(v), &strct.JvmOptions); err != nil {
                return err
             }
        case "replicas":
            if err := json.Unmarshal([]byte(v), &strct.Replicas); err != nil {
                return err
             }
            replicasReceived = true
        case "resources":
            if err := json.Unmarshal([]byte(v), &strct.Resources); err != nil {
                return err
             }
        case "roles":
            if err := json.Unmarshal([]byte(v), &strct.Roles); err != nil {
                return err
             }
            rolesReceived = true
        case "storage":
            if err := json.Unmarshal([]byte(v), &strct.Storage); err != nil {
                return err
             }
            storageReceived = true
        case "template":
            if err := json.Unmarshal([]byte(v), &strct.Template); err != nil {
                return err
             }
        }
    }
    // check if replicas (a required property) was received
    if !replicasReceived {
        return errors.New("\"replicas\" is required but was not present")
    }
    // check if roles (a required property) was received
    if !rolesReceived {
        return errors.New("\"roles\" is required but was not present")
    }
    // check if storage (a required property) was received
    if !storageReceived {
        return errors.New("\"storage\" is required but was not present")
    }
    return nil
}

func (strct *Storage) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "class" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"class\": ")
	if tmp, err := json.Marshal(strct.Class); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "deleteClaim" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"deleteClaim\": ")
	if tmp, err := json.Marshal(strct.DeleteClaim); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "overrides" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"overrides\": ")
	if tmp, err := json.Marshal(strct.Overrides); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "selector" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"selector\": ")
	if tmp, err := json.Marshal(strct.Selector); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "size" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"size\": ")
	if tmp, err := json.Marshal(strct.Size); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sizeLimit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"sizeLimit\": ")
	if tmp, err := json.Marshal(strct.SizeLimit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "volumes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"volumes\": ")
	if tmp, err := json.Marshal(strct.Volumes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Storage) UnmarshalJSON(b []byte) error {
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "class":
            if err := json.Unmarshal([]byte(v), &strct.Class); err != nil {
                return err
             }
        case "deleteClaim":
            if err := json.Unmarshal([]byte(v), &strct.DeleteClaim); err != nil {
                return err
             }
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "overrides":
            if err := json.Unmarshal([]byte(v), &strct.Overrides); err != nil {
                return err
             }
        case "selector":
            if err := json.Unmarshal([]byte(v), &strct.Selector); err != nil {
                return err
             }
        case "size":
            if err := json.Unmarshal([]byte(v), &strct.Size); err != nil {
                return err
             }
        case "sizeLimit":
            if err := json.Unmarshal([]byte(v), &strct.SizeLimit); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        case "volumes":
            if err := json.Unmarshal([]byte(v), &strct.Volumes); err != nil {
                return err
             }
        }
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *VolumesItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "class" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"class\": ")
	if tmp, err := json.Marshal(strct.Class); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "deleteClaim" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"deleteClaim\": ")
	if tmp, err := json.Marshal(strct.DeleteClaim); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "overrides" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"overrides\": ")
	if tmp, err := json.Marshal(strct.Overrides); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "selector" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"selector\": ")
	if tmp, err := json.Marshal(strct.Selector); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "size" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"size\": ")
	if tmp, err := json.Marshal(strct.Size); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sizeLimit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"sizeLimit\": ")
	if tmp, err := json.Marshal(strct.SizeLimit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VolumesItems) UnmarshalJSON(b []byte) error {
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "class":
            if err := json.Unmarshal([]byte(v), &strct.Class); err != nil {
                return err
             }
        case "deleteClaim":
            if err := json.Unmarshal([]byte(v), &strct.DeleteClaim); err != nil {
                return err
             }
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "overrides":
            if err := json.Unmarshal([]byte(v), &strct.Overrides); err != nil {
                return err
             }
        case "selector":
            if err := json.Unmarshal([]byte(v), &strct.Selector); err != nil {
                return err
             }
        case "size":
            if err := json.Unmarshal([]byte(v), &strct.Size); err != nil {
                return err
             }
        case "sizeLimit":
            if err := json.Unmarshal([]byte(v), &strct.SizeLimit); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        }
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}
