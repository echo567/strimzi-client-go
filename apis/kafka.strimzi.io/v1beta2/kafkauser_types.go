// Code generated by schema-generate. DO NOT EDIT.

package v1beta2

import (
    "bytes"
    "errors"
    "encoding/json"
)

// AclsItems 
type AclsItems struct {

  // The host from which the action described in the ACL rule is allowed or denied.
  Host string `json:"host,omitempty"`

  // Operation which will be allowed or denied. Supported operations are: Read, Write, Create, Delete, Alter, Describe, ClusterAction, AlterConfigs, DescribeConfigs, IdempotentWrite and All.
  Operation string `json:"operation,omitempty"`

  // List of operations which will be allowed or denied. Supported operations are: Read, Write, Create, Delete, Alter, Describe, ClusterAction, AlterConfigs, DescribeConfigs, IdempotentWrite and All.
  Operations []string `json:"operations,omitempty"`

  // Indicates the resource for which given ACL rule applies.
  Resource *Resource `json:"resource"`

  // The type of the rule. Currently the only supported type is `allow`. ACL rules with type `allow` are used to allow user to execute the specified operations. Default value is `allow`.
  Type string `json:"type,omitempty"`
}

// Annotations Annotations added to the Kubernetes resource.
type Annotations struct {
}

// Authentication Authentication mechanism enabled for this Kafka user. The supported authentication mechanisms are `scram-sha-512`, `tls`, and `tls-external`. 
// 
// * `scram-sha-512` generates a secret with SASL SCRAM-SHA-512 credentials.
// * `tls` generates a secret with user certificate for mutual TLS authentication.
// * `tls-external` does not generate a user certificate.   But prepares the user for using mutual TLS authentication using a user certificate generated outside the User Operator.
//   ACLs and quotas set for this user are configured in the `CN=<username>` format.
// 
// Authentication is optional. If authentication is not configured, no credentials are generated. ACLs and quotas set for the user are configured in the `<username>` format suitable for SASL authentication.
type Authentication struct {

  // Specify the password for the user. If not set, a new password is generated by the User Operator.
  Password *Password `json:"password,omitempty"`

  // Authentication type.
  Type string `json:"type"`
}

// Authorization Authorization rules for this Kafka user.
type Authorization struct {

  // List of ACL rules which should be applied to this user.
  Acls []*AclsItems `json:"acls"`

  // Authorization type. Currently the only supported type is `simple`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization.
  Type string `json:"type"`
}

// ConditionsItems 
type ConditionsItems struct {

  // Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
  LastTransitionTime string `json:"lastTransitionTime,omitempty"`

  // Human-readable message indicating details about the condition's last transition.
  Message string `json:"message,omitempty"`

  // The reason for the condition's last transition (a single word in CamelCase).
  Reason string `json:"reason,omitempty"`

  // The status of the condition, either True, False or Unknown.
  Status string `json:"status,omitempty"`

  // The unique identifier of a condition, used to distinguish between other conditions in the resource.
  Type string `json:"type,omitempty"`
}

// KafkaUser 
type KafkaUser struct {

  // The specification of the user.
  Spec *Spec `json:"spec,omitempty"`

  // The status of the Kafka User.
  Status *Status `json:"status,omitempty"`
}

// Labels Labels added to the Kubernetes resource.
type Labels struct {
}

// Metadata Metadata applied to the resource.
type Metadata struct {

  // Annotations added to the Kubernetes resource.
  Annotations *Annotations `json:"annotations,omitempty"`

  // Labels added to the Kubernetes resource.
  Labels *Labels `json:"labels,omitempty"`
}

// Password Specify the password for the user. If not set, a new password is generated by the User Operator.
type Password struct {

  // Secret from which the password should be read.
  ValueFrom *ValueFrom `json:"valueFrom"`
}

// Quotas Quotas on requests to control the broker resources used by clients. Network bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka User quotas can be found at http://kafka.apache.org/documentation/#design_quotas.
type Quotas struct {

  // A quota on the maximum bytes per-second that each client group can fetch from a broker before the clients in the group are throttled. Defined on a per-broker basis.
  ConsumerByteRate int `json:"consumerByteRate,omitempty"`

  // A quota on the rate at which mutations are accepted for the create topics request, the create partitions request and the delete topics request. The rate is accumulated by the number of partitions created or deleted.
  ControllerMutationRate float64 `json:"controllerMutationRate,omitempty"`

  // A quota on the maximum bytes per-second that each client group can publish to a broker before the clients in the group are throttled. Defined on a per-broker basis.
  ProducerByteRate int `json:"producerByteRate,omitempty"`

  // A quota on the maximum CPU utilization of each client group as a percentage of network and I/O threads.
  RequestPercentage int `json:"requestPercentage,omitempty"`
}

// Resource Indicates the resource for which given ACL rule applies.
type Resource struct {

  // Name of resource for which given ACL rule applies. Can be combined with `patternType` field to use prefix pattern.
  Name string `json:"name,omitempty"`

  // Describes the pattern used in the resource field. The supported types are `literal` and `prefix`. With `literal` pattern type, the resource field will be used as a definition of a full name. With `prefix` pattern type, the resource name will be used only as a prefix. Default value is `literal`.
  PatternType string `json:"patternType,omitempty"`

  // Resource type. The available resource types are `topic`, `group`, `cluster`, and `transactionalId`.
  Type string `json:"type"`
}

// Secret Template for KafkaUser resources. The template allows users to specify how the `Secret` with password or TLS certificates is generated.
type Secret struct {

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// SecretKeyRef Selects a key of a Secret in the resource's namespace.
type SecretKeyRef struct {
  Key string `json:"key,omitempty"`
  Name string `json:"name,omitempty"`
  Optional bool `json:"optional,omitempty"`
}

// Spec The specification of the user.
type Spec struct {

  // Authentication mechanism enabled for this Kafka user. The supported authentication mechanisms are `scram-sha-512`, `tls`, and `tls-external`. 
  // 
  // * `scram-sha-512` generates a secret with SASL SCRAM-SHA-512 credentials.
  // * `tls` generates a secret with user certificate for mutual TLS authentication.
  // * `tls-external` does not generate a user certificate.   But prepares the user for using mutual TLS authentication using a user certificate generated outside the User Operator.
  //   ACLs and quotas set for this user are configured in the `CN=<username>` format.
  // 
  // Authentication is optional. If authentication is not configured, no credentials are generated. ACLs and quotas set for the user are configured in the `<username>` format suitable for SASL authentication.
  Authentication *Authentication `json:"authentication,omitempty"`

  // Authorization rules for this Kafka user.
  Authorization *Authorization `json:"authorization,omitempty"`

  // Quotas on requests to control the broker resources used by clients. Network bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka User quotas can be found at http://kafka.apache.org/documentation/#design_quotas.
  Quotas *Quotas `json:"quotas,omitempty"`

  // Template to specify how Kafka User `Secrets` are generated.
  Template *Template `json:"template,omitempty"`
}

// Status The status of the Kafka User.
type Status struct {

  // List of status conditions.
  Conditions []*ConditionsItems `json:"conditions,omitempty"`

  // The generation of the CRD that was last reconciled by the operator.
  ObservedGeneration int `json:"observedGeneration,omitempty"`

  // The name of `Secret` where the credentials are stored.
  Secret string `json:"secret,omitempty"`

  // Username.
  Username string `json:"username,omitempty"`
}

// Template Template to specify how Kafka User `Secrets` are generated.
type Template struct {

  // Template for KafkaUser resources. The template allows users to specify how the `Secret` with password or TLS certificates is generated.
  Secret *Secret `json:"secret,omitempty"`
}

// ValueFrom Secret from which the password should be read.
type ValueFrom struct {

  // Selects a key of a Secret in the resource's namespace.
  SecretKeyRef *SecretKeyRef `json:"secretKeyRef,omitempty"`
}

func (strct *AclsItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "operation" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"operation\": ")
	if tmp, err := json.Marshal(strct.Operation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "operations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"operations\": ")
	if tmp, err := json.Marshal(strct.Operations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Resource" field is required
    if strct.Resource == nil {
        return nil, errors.New("resource is a required field")
    }
    // Marshal the "resource" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"resource\": ")
	if tmp, err := json.Marshal(strct.Resource); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AclsItems) UnmarshalJSON(b []byte) error {
    resourceReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
        case "operation":
            if err := json.Unmarshal([]byte(v), &strct.Operation); err != nil {
                return err
             }
        case "operations":
            if err := json.Unmarshal([]byte(v), &strct.Operations); err != nil {
                return err
             }
        case "resource":
            if err := json.Unmarshal([]byte(v), &strct.Resource); err != nil {
                return err
             }
            resourceReceived = true
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        }
    }
    // check if resource (a required property) was received
    if !resourceReceived {
        return errors.New("\"resource\" is required but was not present")
    }
    return nil
}

func (strct *Authentication) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "password" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"password\": ")
	if tmp, err := json.Marshal(strct.Password); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Authentication) UnmarshalJSON(b []byte) error {
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "password":
            if err := json.Unmarshal([]byte(v), &strct.Password); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        }
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *Authorization) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Acls" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "acls" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"acls\": ")
	if tmp, err := json.Marshal(strct.Acls); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Authorization) UnmarshalJSON(b []byte) error {
    aclsReceived := false
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "acls":
            if err := json.Unmarshal([]byte(v), &strct.Acls); err != nil {
                return err
             }
            aclsReceived = true
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        }
    }
    // check if acls (a required property) was received
    if !aclsReceived {
        return errors.New("\"acls\" is required but was not present")
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *Password) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ValueFrom" field is required
    if strct.ValueFrom == nil {
        return nil, errors.New("valueFrom is a required field")
    }
    // Marshal the "valueFrom" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"valueFrom\": ")
	if tmp, err := json.Marshal(strct.ValueFrom); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Password) UnmarshalJSON(b []byte) error {
    valueFromReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "valueFrom":
            if err := json.Unmarshal([]byte(v), &strct.ValueFrom); err != nil {
                return err
             }
            valueFromReceived = true
        }
    }
    // check if valueFrom (a required property) was received
    if !valueFromReceived {
        return errors.New("\"valueFrom\" is required but was not present")
    }
    return nil
}

func (strct *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "patternType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"patternType\": ")
	if tmp, err := json.Marshal(strct.PatternType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Resource) UnmarshalJSON(b []byte) error {
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "patternType":
            if err := json.Unmarshal([]byte(v), &strct.PatternType); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        }
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}
