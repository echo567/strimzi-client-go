// Code generated by schema-generate. DO NOT EDIT.

package v1beta2

import (
    "bytes"
    "encoding/json"
    "errors"
)

// AddressesItems 
type AddressesItems struct {

  // The DNS name or IP address of the Kafka bootstrap service.
  Host string `json:"host,omitempty"`

  // The port of the Kafka bootstrap service.
  Port int `json:"port,omitempty"`
}

// Affinity The pod's affinity rules.
type Affinity struct {
  NodeAffinity *NodeAffinity `json:"nodeAffinity,omitempty"`
  PodAffinity *PodAffinity `json:"podAffinity,omitempty"`
  PodAntiAffinity *PodAntiAffinity `json:"podAntiAffinity,omitempty"`
}

// Annotations Annotations added to the Kubernetes resource.
type Annotations struct {
}

// ApiService Template for Cruise Control API `Service`.
type ApiService struct {

  // Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6`. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting.
  IpFamilies []string `json:"ipFamilies,omitempty"`

  // Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type.
  IpFamilyPolicy string `json:"ipFamilyPolicy,omitempty"`

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// Authentication Authentication configuration for connecting to the JMX port.
type Authentication struct {

  // Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
  Type string `json:"type"`
}

// Authorization Authorization configuration for Kafka brokers.
type Authorization struct {

  // Defines whether a Kafka client should be allowed or denied by default when the authorizer fails to query the Open Policy Agent, for example, when it is temporarily unavailable). Defaults to `false` - all actions will be denied.
  AllowOnError bool `json:"allowOnError,omitempty"`

  // Authorization implementation class, which must be available in classpath.
  AuthorizerClass string `json:"authorizerClass,omitempty"`

  // OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
  ClientId string `json:"clientId,omitempty"`

  // The connect timeout in seconds when connecting to authorization server. If not set, the effective connect timeout is 60 seconds.
  ConnectTimeoutSeconds int `json:"connectTimeoutSeconds,omitempty"`

  // Whether authorization decision should be delegated to the 'Simple' authorizer if DENIED by Keycloak Authorization Services policies. Default value is `false`.
  DelegateToKafkaAcls bool `json:"delegateToKafkaAcls,omitempty"`

  // Enable or disable TLS hostname verification. Default value is `false`.
  DisableTlsHostnameVerification bool `json:"disableTlsHostnameVerification,omitempty"`

  // Enable or disable OAuth metrics. The default value is `false`.
  EnableMetrics bool `json:"enableMetrics,omitempty"`

  // The expiration of the records kept in the local cache to avoid querying the Open Policy Agent for every request. Defines how often the cached authorization decisions are reloaded from the Open Policy Agent server. In milliseconds. Defaults to `3600000`.
  ExpireAfterMs int `json:"expireAfterMs,omitempty"`

  // Controls whether the latest grants are fetched for a new session. When enabled, grants are retrieved from Keycloak and cached for the user. The default value is `false`.
  GrantsAlwaysLatest bool `json:"grantsAlwaysLatest,omitempty"`

  // The time, in seconds, between consecutive runs of a job that cleans stale grants from the cache. The default value is 300.
  GrantsGcPeriodSeconds int `json:"grantsGcPeriodSeconds,omitempty"`

  // The time, in seconds, after which an idle grant can be evicted from the cache. The default value is 300.
  GrantsMaxIdleTimeSeconds int `json:"grantsMaxIdleTimeSeconds,omitempty"`

  // The time between two consecutive grants refresh runs in seconds. The default value is 60.
  GrantsRefreshPeriodSeconds int `json:"grantsRefreshPeriodSeconds,omitempty"`

  // The number of threads to use to refresh grants for active sessions. The more threads, the more parallelism, so the sooner the job completes. However, using more threads places a heavier load on the authorization server. The default value is 5.
  GrantsRefreshPoolSize int `json:"grantsRefreshPoolSize,omitempty"`

  // The maximum number of retries to attempt if an initial HTTP request fails. If not set, the default is to not attempt any retries.
  HttpRetries int `json:"httpRetries,omitempty"`

  // Initial capacity of the local cache used by the authorizer to avoid querying the Open Policy Agent for every request Defaults to `5000`.
  InitialCacheCapacity int `json:"initialCacheCapacity,omitempty"`

  // Maximum capacity of the local cache used by the authorizer to avoid querying the Open Policy Agent for every request. Defaults to `50000`.
  MaximumCacheSize int `json:"maximumCacheSize,omitempty"`

  // The read timeout in seconds when connecting to authorization server. If not set, the effective read timeout is 60 seconds.
  ReadTimeoutSeconds int `json:"readTimeoutSeconds,omitempty"`

  // List of super users, which are user principals with unlimited access rights.
  SuperUsers []string `json:"superUsers,omitempty"`

  // Indicates whether the custom authorizer supports the APIs for managing ACLs using the Kafka Admin API. Defaults to `false`.
  SupportsAdminApi bool `json:"supportsAdminApi,omitempty"`

  // Trusted certificates for TLS connection to the OAuth server.
  TlsTrustedCertificates []*TlsTrustedCertificatesItems `json:"tlsTrustedCertificates,omitempty"`

  // Authorization server token endpoint URI.
  TokenEndpointUri string `json:"tokenEndpointUri,omitempty"`

  // Authorization type. Currently, the supported types are `simple`, `keycloak`, `opa` and `custom`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization. `keycloak` authorization type uses Keycloak Authorization Services for authorization. `opa` authorization type uses Open Policy Agent based authorization.`custom` authorization type uses user-provided implementation for authorization.
  Type string `json:"type"`

  // The URL used to connect to the Open Policy Agent server. The URL has to include the policy which will be queried by the authorizer. This option is required.
  Url string `json:"url,omitempty"`
}

// Bootstrap Bootstrap configuration.
type Bootstrap struct {

  // Additional alternative names for the bootstrap service. The alternative names will be added to the list of subject alternative names of the TLS certificates.
  AlternativeNames []string `json:"alternativeNames,omitempty"`

  // Annotations that will be added to the `Ingress`, `Route`, or `Service` resource. You can use this field to configure DNS providers such as External DNS. This field can be used only with `loadbalancer`, `nodeport`, `route`, or `ingress` type listeners.
  Annotations *Annotations `json:"annotations,omitempty"`

  // The bootstrap host. This field will be used in the Ingress resource or in the Route resource to specify the desired hostname. This field can be used only with `route` (optional) or `ingress` (required) type listeners.
  Host string `json:"host,omitempty"`

  // Labels that will be added to the `Ingress`, `Route`, or `Service` resource. This field can be used only with `loadbalancer`, `nodeport`, `route`, or `ingress` type listeners.
  Labels *Labels `json:"labels,omitempty"`

  // The loadbalancer is requested with the IP address specified in this field. This feature depends on whether the underlying cloud provider supports specifying the `loadBalancerIP` when a load balancer is created. This field is ignored if the cloud provider does not support the feature.This field can be used only with `loadbalancer` type listener.
  LoadBalancerIP string `json:"loadBalancerIP,omitempty"`

  // Node port for the bootstrap service. This field can be used only with `nodeport` type listener.
  NodePort int `json:"nodePort,omitempty"`
}

// BootstrapService Template for Kafka bootstrap `Service`.
type BootstrapService struct {

  // Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6`. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting.
  IpFamilies []string `json:"ipFamilies,omitempty"`

  // Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type.
  IpFamilyPolicy string `json:"ipFamilyPolicy,omitempty"`

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// BrokerCapacity The Cruise Control `brokerCapacity` configuration.
type BrokerCapacity struct {

  // Broker capacity for CPU resource in cores or millicores. For example, 1, 1.500, 1500m. For more information on valid CPU resource units see https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu.
  Cpu string `json:"cpu,omitempty"`

  // Broker capacity for CPU resource utilization as a percentage (0 - 100).
  CpuUtilization int `json:"cpuUtilization,omitempty"`

  // Broker capacity for disk in bytes. Use a number value with either standard Kubernetes byte units (K, M, G, or T), their bibyte (power of two) equivalents (Ki, Mi, Gi, or Ti), or a byte value with or without E notation. For example, 100000M, 100000Mi, 104857600000, or 1e+11.
  Disk string `json:"disk,omitempty"`

  // Broker capacity for inbound network throughput in bytes per second. Use an integer value with standard Kubernetes byte units (K, M, G) or their bibyte (power of two) equivalents (Ki, Mi, Gi) per second. For example, 10000KiB/s.
  InboundNetwork string `json:"inboundNetwork,omitempty"`

  // Broker capacity for outbound network throughput in bytes per second. Use an integer value with standard Kubernetes byte units (K, M, G) or their bibyte (power of two) equivalents (Ki, Mi, Gi) per second. For example, 10000KiB/s.
  OutboundNetwork string `json:"outboundNetwork,omitempty"`

  // Overrides for individual brokers. The `overrides` property lets you specify a different capacity configuration for different brokers.
  Overrides []*OverridesItems `json:"overrides,omitempty"`
}

// BrokerCertChainAndKey Reference to the `Secret` which holds the certificate and private key pair which will be used for this listener. The certificate can optionally contain the whole chain. This field can be used only with listeners with enabled TLS encryption.
type BrokerCertChainAndKey struct {

  // The name of the file certificate in the Secret.
  Certificate string `json:"certificate"`

  // The name of the private key in the Secret.
  Key string `json:"key"`

  // The name of the Secret containing the certificate.
  SecretName string `json:"secretName"`
}

// BrokersItems 
type BrokersItems struct {

  // The host name used in the brokers' `advertised.listeners`.
  AdvertisedHost string `json:"advertisedHost,omitempty"`

  // The port number used in the brokers' `advertised.listeners`.
  AdvertisedPort int `json:"advertisedPort,omitempty"`

  // Annotations that will be added to the `Ingress` or `Service` resource. You can use this field to configure DNS providers such as External DNS. This field can be used only with `loadbalancer`, `nodeport`, or `ingress` type listeners.
  Annotations *Annotations `json:"annotations,omitempty"`

  // ID of the kafka broker (broker identifier). Broker IDs start from 0 and correspond to the number of broker replicas.
  Broker int `json:"broker"`

  // The broker host. This field will be used in the Ingress resource or in the Route resource to specify the desired hostname. This field can be used only with `route` (optional) or `ingress` (required) type listeners.
  Host string `json:"host,omitempty"`

  // Labels that will be added to the `Ingress`, `Route`, or `Service` resource. This field can be used only with `loadbalancer`, `nodeport`, `route`, or `ingress` type listeners.
  Labels *Labels `json:"labels,omitempty"`

  // The loadbalancer is requested with the IP address specified in this field. This feature depends on whether the underlying cloud provider supports specifying the `loadBalancerIP` when a load balancer is created. This field is ignored if the cloud provider does not support the feature.This field can be used only with `loadbalancer` type listener.
  LoadBalancerIP string `json:"loadBalancerIP,omitempty"`

  // Node port for the per-broker service. This field can be used only with `nodeport` type listener.
  NodePort int `json:"nodePort,omitempty"`
}

// BrokersService Template for Kafka broker `Service`.
type BrokersService struct {

  // Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6`. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting.
  IpFamilies []string `json:"ipFamilies,omitempty"`

  // Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type.
  IpFamilyPolicy string `json:"ipFamilyPolicy,omitempty"`

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// Capabilities 
type Capabilities struct {
  Add []string `json:"add,omitempty"`
  Drop []string `json:"drop,omitempty"`
}

// ClaimsItems 
type ClaimsItems struct {
  Name string `json:"name,omitempty"`
}

// ClientSecret Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
type ClientSecret struct {

  // The key under which the secret value is stored in the Kubernetes Secret.
  Key string `json:"key"`

  // The name of the Kubernetes Secret containing the secret value.
  SecretName string `json:"secretName"`
}

// ClientService Template for ZooKeeper client `Service`.
type ClientService struct {

  // Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6`. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting.
  IpFamilies []string `json:"ipFamilies,omitempty"`

  // Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type.
  IpFamilyPolicy string `json:"ipFamilyPolicy,omitempty"`

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// ClientsCa Configuration of the clients certificate authority.
type ClientsCa struct {

  // How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
  CertificateExpirationPolicy string `json:"certificateExpirationPolicy,omitempty"`

  // If true then Certificate Authority certificates will be generated automatically. Otherwise the user will need to provide a Secret with the CA certificate. Default is true.
  GenerateCertificateAuthority bool `json:"generateCertificateAuthority,omitempty"`

  // If `true`, the Cluster and Client CA Secrets are configured with the `ownerReference` set to the `Kafka` resource. If the `Kafka` resource is deleted when `true`, the CA Secrets are also deleted. If `false`, the `ownerReference` is disabled. If the `Kafka` resource is deleted when `false`, the CA Secrets are retained and available for reuse. Default is `true`.
  GenerateSecretOwnerReference bool `json:"generateSecretOwnerReference,omitempty"`

  // The number of days in the certificate renewal period. This is the number of days before the a certificate expires during which renewal actions may be performed. When `generateCertificateAuthority` is true, this will cause the generation of a new certificate. When `generateCertificateAuthority` is true, this will cause extra logging at WARN level about the pending certificate expiry. Default is 30.
  RenewalDays int `json:"renewalDays,omitempty"`

  // The number of days generated certificates should be valid for. The default is 365.
  ValidityDays int `json:"validityDays,omitempty"`
}

// ClusterCa Configuration of the cluster certificate authority.
type ClusterCa struct {

  // How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
  CertificateExpirationPolicy string `json:"certificateExpirationPolicy,omitempty"`

  // If true then Certificate Authority certificates will be generated automatically. Otherwise the user will need to provide a Secret with the CA certificate. Default is true.
  GenerateCertificateAuthority bool `json:"generateCertificateAuthority,omitempty"`

  // If `true`, the Cluster and Client CA Secrets are configured with the `ownerReference` set to the `Kafka` resource. If the `Kafka` resource is deleted when `true`, the CA Secrets are also deleted. If `false`, the `ownerReference` is disabled. If the `Kafka` resource is deleted when `false`, the CA Secrets are retained and available for reuse. Default is `true`.
  GenerateSecretOwnerReference bool `json:"generateSecretOwnerReference,omitempty"`

  // The number of days in the certificate renewal period. This is the number of days before the a certificate expires during which renewal actions may be performed. When `generateCertificateAuthority` is true, this will cause the generation of a new certificate. When `generateCertificateAuthority` is true, this will cause extra logging at WARN level about the pending certificate expiry. Default is 30.
  RenewalDays int `json:"renewalDays,omitempty"`

  // The number of days generated certificates should be valid for. The default is 365.
  ValidityDays int `json:"validityDays,omitempty"`
}

// ClusterCaCert Template for Secret with Kafka Cluster certificate public key.
type ClusterCaCert struct {

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// ClusterRoleBinding Template for the Kafka ClusterRoleBinding.
type ClusterRoleBinding struct {

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// ConditionsItems 
type ConditionsItems struct {

  // Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
  LastTransitionTime string `json:"lastTransitionTime,omitempty"`

  // Human-readable message indicating details about the condition's last transition.
  Message string `json:"message,omitempty"`

  // The reason for the condition's last transition (a single word in CamelCase).
  Reason string `json:"reason,omitempty"`

  // The status of the condition, either True, False or Unknown.
  Status string `json:"status,omitempty"`

  // The unique identifier of a condition, used to distinguish between other conditions in the resource.
  Type string `json:"type,omitempty"`
}

// Config The ZooKeeper broker config. Properties with the following prefixes cannot be set: server., dataDir, dataLogDir, clientPort, authProvider, quorum.auth, requireClientAuthScheme, snapshot.trust.empty, standaloneEnabled, reconfigEnabled, 4lw.commands.whitelist, secureClientPort, ssl., serverCnxnFactory, sslQuorum (with the exception of: ssl.protocol, ssl.quorum.protocol, ssl.enabledProtocols, ssl.quorum.enabledProtocols, ssl.ciphersuites, ssl.quorum.ciphersuites, ssl.hostnameVerification, ssl.quorum.hostnameVerification).
type Config struct {
}

// ConfigMapKeyRef Reference to the key in the ConfigMap containing the configuration.
type ConfigMapKeyRef struct {
  Key string `json:"key,omitempty"`
  Name string `json:"name,omitempty"`
  Optional bool `json:"optional,omitempty"`
}

// Configuration Additional listener configuration.
type Configuration struct {

  // Bootstrap configuration.
  Bootstrap *Bootstrap `json:"bootstrap,omitempty"`

  // Reference to the `Secret` which holds the certificate and private key pair which will be used for this listener. The certificate can optionally contain the whole chain. This field can be used only with listeners with enabled TLS encryption.
  BrokerCertChainAndKey *BrokerCertChainAndKey `json:"brokerCertChainAndKey,omitempty"`

  // Per-broker configurations.
  Brokers []*BrokersItems `json:"brokers,omitempty"`

  // Configures a specific class for `Ingress` and `LoadBalancer` that defines which controller will be used. This field can only be used with `ingress` and `loadbalancer` type listeners. If not specified, the default controller is used. For an `ingress` listener, set the `ingressClassName` property in the `Ingress` resources. For a `loadbalancer` listener, set the `loadBalancerClass` property  in the `Service` resources.
  Class string `json:"class,omitempty"`

  // Whether to create the bootstrap service or not. The bootstrap service is created by default (if not specified differently). This field can be used with the `loadBalancer` type listener.
  CreateBootstrapService bool `json:"createBootstrapService,omitempty"`

  // Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.This field can be used only with `loadbalancer` or `nodeport` type listener.
  ExternalTrafficPolicy string `json:"externalTrafficPolicy,omitempty"`

  // A list of finalizers which will be configured for the `LoadBalancer` type Services created for this listener. If supported by the platform, the finalizer `service.kubernetes.io/load-balancer-cleanup` to make sure that the external load balancer is deleted together with the service.For more information, see https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#garbage-collecting-load-balancers. This field can be used only with `loadbalancer` type listeners.
  Finalizers []string `json:"finalizers,omitempty"`

  // Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6`. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting.
  IpFamilies []string `json:"ipFamilies,omitempty"`

  // Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type.
  IpFamilyPolicy string `json:"ipFamilyPolicy,omitempty"`

  // A list of CIDR ranges (for example `10.0.0.0/8` or `130.211.204.1/32`) from which clients can connect to load balancer type listeners. If supported by the platform, traffic through the loadbalancer is restricted to the specified CIDR ranges. This field is applicable only for loadbalancer type services and is ignored if the cloud provider does not support the feature. This field can be used only with `loadbalancer` type listener.
  LoadBalancerSourceRanges []string `json:"loadBalancerSourceRanges,omitempty"`

  // The maximum connection creation rate we allow in this listener at any time. New connections will be throttled if the limit is reached.
  MaxConnectionCreationRate int `json:"maxConnectionCreationRate,omitempty"`

  // The maximum number of connections we allow for this listener in the broker at any time. New connections are blocked if the limit is reached.
  MaxConnections int `json:"maxConnections,omitempty"`

  // Defines which address type should be used as the node address. Available types are: `ExternalDNS`, `ExternalIP`, `InternalDNS`, `InternalIP` and `Hostname`. By default, the addresses will be used in the following order (the first one found will be used):
  // 
  // * `ExternalDNS`
  // * `ExternalIP`
  // * `InternalDNS`
  // * `InternalIP`
  // * `Hostname`
  // 
  // This field is used to select the preferred address type, which is checked first. If no address is found for this address type, the other types are checked in the default order. This field can only be used with `nodeport` type listener.
  PreferredNodePortAddressType string `json:"preferredNodePortAddressType,omitempty"`

  // Configures whether the Kubernetes service DNS domain should be used or not. If set to `true`, the generated addresses will contain the service DNS domain suffix (by default `.cluster.local`, can be configured using environment variable `KUBERNETES_SERVICE_DNS_DOMAIN`). Defaults to `false`.This field can be used only with `internal` and `cluster-ip` type listeners.
  UseServiceDnsDomain bool `json:"useServiceDnsDomain,omitempty"`
}

// Container Template for JmxTrans container.
type Container struct {

  // Environment variables which should be applied to the container.
  Env []*EnvItems `json:"env,omitempty"`

  // Security context for the container.
  SecurityContext *SecurityContext `json:"securityContext,omitempty"`
}

// CruiseControl Configuration for Cruise Control deployment. Deploys a Cruise Control instance when specified.
type CruiseControl struct {

  // The Cruise Control `brokerCapacity` configuration.
  BrokerCapacity *BrokerCapacity `json:"brokerCapacity,omitempty"`

  // The Cruise Control configuration. For a full list of configuration options refer to https://github.com/linkedin/cruise-control/wiki/Configurations. Note that properties with the following prefixes cannot be set: bootstrap.servers, client.id, zookeeper., network., security., failed.brokers.zk.path,webserver.http., webserver.api.urlprefix, webserver.session.path, webserver.accesslog., two.step., request.reason.required,metric.reporter.sampler.bootstrap.servers, capacity.config.file, self.healing., ssl., kafka.broker.failure.detection.enable, topic.config.provider.class (with the exception of: ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols, webserver.http.cors.enabled, webserver.http.cors.origin, webserver.http.cors.exposeheaders, webserver.security.enable, webserver.ssl.enable).
  Config *Config `json:"config,omitempty"`

  // The docker image for the pods.
  Image string `json:"image,omitempty"`

  // JVM Options for the Cruise Control container.
  JvmOptions *JvmOptions `json:"jvmOptions,omitempty"`

  // Pod liveness checking for the Cruise Control container.
  LivenessProbe *LivenessProbe `json:"livenessProbe,omitempty"`

  // Logging configuration (Log4j 2) for Cruise Control.
  Logging *Logging `json:"logging,omitempty"`

  // Metrics configuration.
  MetricsConfig *MetricsConfig `json:"metricsConfig,omitempty"`

  // Pod readiness checking for the Cruise Control container.
  ReadinessProbe *ReadinessProbe `json:"readinessProbe,omitempty"`

  // CPU and memory resources to reserve for the Cruise Control container.
  Resources *Resources `json:"resources,omitempty"`

  // Template to specify how Cruise Control resources, `Deployments` and `Pods`, are generated.
  Template *Template `json:"template,omitempty"`

  // TLS sidecar configuration.
  TlsSidecar *TlsSidecar `json:"tlsSidecar,omitempty"`
}

// CruiseControlContainer Template for the Cruise Control container.
type CruiseControlContainer struct {

  // Environment variables which should be applied to the container.
  Env []*EnvItems `json:"env,omitempty"`

  // Security context for the container.
  SecurityContext *SecurityContext `json:"securityContext,omitempty"`
}

// Deployment Template for JmxTrans `Deployment`.
type Deployment struct {

  // Pod replacement strategy for deployment configuration changes. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.
  DeploymentStrategy string `json:"deploymentStrategy,omitempty"`

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// EntityOperator Configuration of the Entity Operator.
type EntityOperator struct {

  // Template for Entity Operator resources. The template allows users to specify how a `Deployment` and `Pod` is generated.
  Template *Template `json:"template,omitempty"`

  // TLS sidecar configuration.
  TlsSidecar *TlsSidecar `json:"tlsSidecar,omitempty"`

  // Configuration of the Topic Operator.
  TopicOperator *TopicOperator `json:"topicOperator,omitempty"`

  // Configuration of the User Operator.
  UserOperator *UserOperator `json:"userOperator,omitempty"`
}

// EntityOperatorRole Template for the Entity Operator Role.
type EntityOperatorRole struct {

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// EnvItems 
type EnvItems struct {

  // The environment variable key.
  Name string `json:"name,omitempty"`

  // The environment variable value.
  Value string `json:"value,omitempty"`
}

// ExternalBootstrapIngress Template for Kafka external bootstrap `Ingress`.
type ExternalBootstrapIngress struct {

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// ExternalBootstrapRoute Template for Kafka external bootstrap `Route`.
type ExternalBootstrapRoute struct {

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// ExternalBootstrapService Template for Kafka external bootstrap `Service`.
type ExternalBootstrapService struct {

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// HostAliasesItems 
type HostAliasesItems struct {
  Hostnames []string `json:"hostnames,omitempty"`
  Ip string `json:"ip,omitempty"`
}

// ImagePullSecretsItems 
type ImagePullSecretsItems struct {
  Name string `json:"name,omitempty"`
}

// InitContainer Template for the Kafka init container.
type InitContainer struct {

  // Environment variables which should be applied to the container.
  Env []*EnvItems `json:"env,omitempty"`

  // Security context for the container.
  SecurityContext *SecurityContext `json:"securityContext,omitempty"`
}

// IpBlock 
type IpBlock struct {
  Cidr string `json:"cidr,omitempty"`
  Except []string `json:"except,omitempty"`
}

// JavaSystemPropertiesItems 
type JavaSystemPropertiesItems struct {

  // The system property name.
  Name string `json:"name,omitempty"`

  // The system property value.
  Value string `json:"value,omitempty"`
}

// JmxOptions JMX Options for Zookeeper nodes.
type JmxOptions struct {

  // Authentication configuration for connecting to the JMX port.
  Authentication *Authentication `json:"authentication,omitempty"`
}

// JmxSecret Template for Secret of the Zookeeper Cluster JMX authentication.
type JmxSecret struct {

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// JmxTrans As of Strimzi 0.35.0, JMXTrans is not supported anymore and this option is ignored.
type JmxTrans struct {

  // The image to use for the JmxTrans.
  Image string `json:"image,omitempty"`

  // Queries to send to the Kafka brokers to define what data should be read from each broker. For more information on these properties see, xref:type-JmxTransQueryTemplate-reference[`JmxTransQueryTemplate` schema reference].
  KafkaQueries []*KafkaQueriesItems `json:"kafkaQueries"`

  // Sets the logging level of the JmxTrans deployment.For more information see, https://github.com/jmxtrans/jmxtrans-agent/wiki/Troubleshooting[JmxTrans Logging Level].
  LogLevel string `json:"logLevel,omitempty"`

  // Defines the output hosts that will be referenced later on. For more information on these properties see, xref:type-JmxTransOutputDefinitionTemplate-reference[`JmxTransOutputDefinitionTemplate` schema reference].
  OutputDefinitions []*OutputDefinitionsItems `json:"outputDefinitions"`

  // CPU and memory resources to reserve.
  Resources *Resources `json:"resources,omitempty"`

  // Template for JmxTrans resources.
  Template *Template `json:"template,omitempty"`
}

// JvmOptions JVM Options for pods.
type JvmOptions struct {

  // Specifies whether the Garbage Collection logging is enabled. The default is false.
  GcLoggingEnabled bool `json:"gcLoggingEnabled,omitempty"`

  // A map of additional system properties which will be passed using the `-D` option to the JVM.
  JavaSystemProperties []*JavaSystemPropertiesItems `json:"javaSystemProperties,omitempty"`

  // A map of -XX options to the JVM.
  XX *XX `json:"-XX,omitempty"`

  // -Xms option to to the JVM.
  Xms string `json:"-Xms,omitempty"`

  // -Xmx option to to the JVM.
  Xmx string `json:"-Xmx,omitempty"`
}

// Kafka 
type Kafka struct {

  // The specification of the Kafka and ZooKeeper clusters, and Topic Operator.
  Spec *Spec `json:"spec,omitempty"`

  // The status of the Kafka and ZooKeeper clusters, and Topic Operator.
  Status *Status `json:"status,omitempty"`
}

// KafkaContainer Template for the Kafka broker container.
type KafkaContainer struct {

  // Environment variables which should be applied to the container.
  Env []*EnvItems `json:"env,omitempty"`

  // Security context for the container.
  SecurityContext *SecurityContext `json:"securityContext,omitempty"`
}

// KafkaExporter Configuration of the Kafka Exporter. Kafka Exporter can provide additional metrics, for example lag of consumer group at topic/partition.
type KafkaExporter struct {

  // Enable Sarama logging, a Go client library used by the Kafka Exporter.
  EnableSaramaLogging bool `json:"enableSaramaLogging,omitempty"`

  // Regular expression to specify which consumer groups to exclude.
  GroupExcludeRegex string `json:"groupExcludeRegex,omitempty"`

  // Regular expression to specify which consumer groups to collect. Default value is `.*`.
  GroupRegex string `json:"groupRegex,omitempty"`

  // The docker image for the pods.
  Image string `json:"image,omitempty"`

  // Pod liveness check.
  LivenessProbe *LivenessProbe `json:"livenessProbe,omitempty"`

  // Only log messages with the given severity or above. Valid levels: [`info`, `debug`, `trace`]. Default log level is `info`.
  Logging string `json:"logging,omitempty"`

  // Pod readiness check.
  ReadinessProbe *ReadinessProbe `json:"readinessProbe,omitempty"`

  // CPU and memory resources to reserve.
  Resources *Resources `json:"resources,omitempty"`

  // Customization of deployment templates and pods.
  Template *Template `json:"template,omitempty"`

  // Regular expression to specify which topics to exclude.
  TopicExcludeRegex string `json:"topicExcludeRegex,omitempty"`

  // Regular expression to specify which topics to collect. Default value is `.*`.
  TopicRegex string `json:"topicRegex,omitempty"`
}

// KafkaNodePoolsItems 
type KafkaNodePoolsItems struct {

  // The name of the KafkaNodePool used by this Kafka resource.
  Name string `json:"name,omitempty"`
}

// KafkaQueriesItems 
type KafkaQueriesItems struct {

  // Determine which attributes of the targeted MBean should be included.
  Attributes []string `json:"attributes"`

  // List of the names of output definitions specified in the spec.kafka.jmxTrans.outputDefinitions that have defined where JMX metrics are pushed to, and in which data format.
  Outputs []string `json:"outputs"`

  // If using wildcards instead of a specific MBean then the data is gathered from multiple MBeans. Otherwise if specifying an MBean then data is gathered from that specified MBean.
  TargetMBean string `json:"targetMBean"`
}

// LabelSelector 
type LabelSelector struct {
  MatchExpressions []*MatchExpressionsItems `json:"matchExpressions,omitempty"`
  MatchLabels *MatchLabels `json:"matchLabels,omitempty"`
}

// Labels Labels added to the Kubernetes resource.
type Labels struct {
}

// Limits 
type Limits struct {
}

// ListenerConfig Configuration to be used for a specific listener. All values are prefixed with listener.name._<listener_name>_.
type ListenerConfig struct {
}

// ListenersItems 
type ListenersItems struct {

  // A list of the addresses for this listener.
  Addresses []*AddressesItems `json:"addresses,omitempty"`

  // A comma-separated list of `host:port` pairs for connecting to the Kafka cluster using this listener.
  BootstrapServers string `json:"bootstrapServers,omitempty"`

  // A list of TLS certificates which can be used to verify the identity of the server when connecting to the given listener. Set only for `tls` and `external` listeners.
  Certificates []string `json:"certificates,omitempty"`

  // The name of the listener.
  Name string `json:"name,omitempty"`

  // *The `type` property has been deprecated, and should now be configured using `name`.* The name of the listener.
  Type string `json:"type,omitempty"`
}

// LivenessProbe Pod liveness checking.
type LivenessProbe struct {

  // Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
  FailureThreshold int `json:"failureThreshold,omitempty"`

  // The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
  InitialDelaySeconds int `json:"initialDelaySeconds,omitempty"`

  // How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
  PeriodSeconds int `json:"periodSeconds,omitempty"`

  // Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
  SuccessThreshold int `json:"successThreshold,omitempty"`

  // The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
  TimeoutSeconds int `json:"timeoutSeconds,omitempty"`
}

// Loggers A Map from logger name to logger level.
type Loggers struct {
}

// Logging Logging configuration for ZooKeeper.
type Logging struct {

  // A Map from logger name to logger level.
  Loggers *Loggers `json:"loggers,omitempty"`

  // Logging type, must be either 'inline' or 'external'.
  Type string `json:"type"`

  // `ConfigMap` entry where the logging configuration is stored. 
  ValueFrom *ValueFrom `json:"valueFrom,omitempty"`
}

// MatchExpressionsItems 
type MatchExpressionsItems struct {
  Key string `json:"key,omitempty"`
  Operator string `json:"operator,omitempty"`
  Values []string `json:"values,omitempty"`
}

// MatchFieldsItems 
type MatchFieldsItems struct {
  Key string `json:"key,omitempty"`
  Operator string `json:"operator,omitempty"`
  Values []string `json:"values,omitempty"`
}

// MatchLabels 
type MatchLabels struct {
}

// Metadata Metadata applied to the resource.
type Metadata struct {

  // Annotations added to the Kubernetes resource.
  Annotations *Annotations `json:"annotations,omitempty"`

  // Labels added to the Kubernetes resource.
  Labels *Labels `json:"labels,omitempty"`
}

// MetricsConfig Metrics configuration.
type MetricsConfig struct {

  // Metrics type. Only 'jmxPrometheusExporter' supported currently.
  Type string `json:"type"`

  // ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.
  ValueFrom *ValueFrom `json:"valueFrom"`
}

// NamespaceSelector 
type NamespaceSelector struct {
  MatchExpressions []*MatchExpressionsItems `json:"matchExpressions,omitempty"`
  MatchLabels *MatchLabels `json:"matchLabels,omitempty"`
}

// NetworkPolicyPeersItems 
type NetworkPolicyPeersItems struct {
  IpBlock *IpBlock `json:"ipBlock,omitempty"`
  NamespaceSelector *NamespaceSelector `json:"namespaceSelector,omitempty"`
  PodSelector *PodSelector `json:"podSelector,omitempty"`
}

// NodeAffinity 
type NodeAffinity struct {
  PreferredDuringSchedulingIgnoredDuringExecution []*PreferredDuringSchedulingIgnoredDuringExecutionItems `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`
  RequiredDuringSchedulingIgnoredDuringExecution *RequiredDuringSchedulingIgnoredDuringExecution `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

// NodeSelectorTermsItems 
type NodeSelectorTermsItems struct {
  MatchExpressions []*MatchExpressionsItems `json:"matchExpressions,omitempty"`
  MatchFields []*MatchFieldsItems `json:"matchFields,omitempty"`
}

// NodesService Template for ZooKeeper nodes `Service`.
type NodesService struct {

  // Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6`. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting.
  IpFamilies []string `json:"ipFamilies,omitempty"`

  // Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type.
  IpFamilyPolicy string `json:"ipFamilyPolicy,omitempty"`

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// OutputDefinitionsItems 
type OutputDefinitionsItems struct {

  // How many seconds the JmxTrans waits before pushing a new set of data out.
  FlushDelayInSeconds int `json:"flushDelayInSeconds,omitempty"`

  // The DNS/hostname of the remote host that the data is pushed to.
  Host string `json:"host,omitempty"`

  // Template for setting the name of the output definition. This is used to identify where to send the results of queries should be sent.
  Name string `json:"name"`

  // Template for setting the format of the data that will be pushed.For more information see https://github.com/jmxtrans/jmxtrans/wiki/OutputWriters[JmxTrans OutputWriters].
  OutputType string `json:"outputType"`

  // The port of the remote host that the data is pushed to.
  Port int `json:"port,omitempty"`

  // Template for filtering data to be included in response to a wildcard query. For more information see https://github.com/jmxtrans/jmxtrans/wiki/Queries[JmxTrans queries].
  TypeNames []string `json:"typeNames,omitempty"`
}

// OverridesItems 
type OverridesItems struct {

  // Id of the kafka broker (broker identifier).
  Broker int `json:"broker,omitempty"`

  // The storage class to use for dynamic volume allocation for this broker.
  Class string `json:"class,omitempty"`
}

// PerPodIngress Template for Kafka per-pod `Ingress` used for access from outside of Kubernetes.
type PerPodIngress struct {

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// PerPodRoute Template for Kafka per-pod `Routes` used for access from outside of OpenShift.
type PerPodRoute struct {

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// PerPodService Template for Kafka per-pod `Services` used for access from outside of Kubernetes.
type PerPodService struct {

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// PersistentVolumeClaim Template for all ZooKeeper `PersistentVolumeClaims`.
type PersistentVolumeClaim struct {

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// Pod Template for JmxTrans `Pods`.
type Pod struct {

  // The pod's affinity rules.
  Affinity *Affinity `json:"affinity,omitempty"`

  // Indicates whether information about services should be injected into Pod's environment variables.
  EnableServiceLinks bool `json:"enableServiceLinks,omitempty"`

  // The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
  HostAliases []*HostAliasesItems `json:"hostAliases,omitempty"`

  // List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
  ImagePullSecrets []*ImagePullSecretsItems `json:"imagePullSecrets,omitempty"`

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`

  // The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
  PriorityClassName string `json:"priorityClassName,omitempty"`

  // The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
  SchedulerName string `json:"schedulerName,omitempty"`

  // Configures pod-level security attributes and common container settings.
  SecurityContext *SecurityContext `json:"securityContext,omitempty"`

  // The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
  TerminationGracePeriodSeconds int `json:"terminationGracePeriodSeconds,omitempty"`

  // Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.
  TmpDirSizeLimit string `json:"tmpDirSizeLimit,omitempty"`

  // The pod's tolerations.
  Tolerations []*TolerationsItems `json:"tolerations,omitempty"`

  // The pod's topology spread constraints.
  TopologySpreadConstraints []*TopologySpreadConstraintsItems `json:"topologySpreadConstraints,omitempty"`
}

// PodAffinity 
type PodAffinity struct {
  PreferredDuringSchedulingIgnoredDuringExecution []*PreferredDuringSchedulingIgnoredDuringExecutionItems `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`
  RequiredDuringSchedulingIgnoredDuringExecution []*RequiredDuringSchedulingIgnoredDuringExecutionItems `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

// PodAffinityTerm 
type PodAffinityTerm struct {
  LabelSelector *LabelSelector `json:"labelSelector,omitempty"`
  NamespaceSelector *NamespaceSelector `json:"namespaceSelector,omitempty"`
  Namespaces []string `json:"namespaces,omitempty"`
  TopologyKey string `json:"topologyKey,omitempty"`
}

// PodAntiAffinity 
type PodAntiAffinity struct {
  PreferredDuringSchedulingIgnoredDuringExecution []*PreferredDuringSchedulingIgnoredDuringExecutionItems `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`
  RequiredDuringSchedulingIgnoredDuringExecution []*RequiredDuringSchedulingIgnoredDuringExecutionItems `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

// PodDisruptionBudget Template for ZooKeeper `PodDisruptionBudget`.
type PodDisruptionBudget struct {

  // Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
  MaxUnavailable int `json:"maxUnavailable,omitempty"`

  // Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// PodSelector 
type PodSelector struct {
  MatchExpressions []*MatchExpressionsItems `json:"matchExpressions,omitempty"`
  MatchLabels *MatchLabels `json:"matchLabels,omitempty"`
}

// PodSet Template for ZooKeeper `StrimziPodSet` resource.
type PodSet struct {

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// Preference 
type Preference struct {
  MatchExpressions []*MatchExpressionsItems `json:"matchExpressions,omitempty"`
  MatchFields []*MatchFieldsItems `json:"matchFields,omitempty"`
}

// PreferredDuringSchedulingIgnoredDuringExecutionItems 
type PreferredDuringSchedulingIgnoredDuringExecutionItems struct {
  Preference *Preference `json:"preference,omitempty"`
  Weight int `json:"weight,omitempty"`
}

// Rack Configuration of the `broker.rack` broker config.
type Rack struct {

  // A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set a broker's `broker.rack` config, and the `client.rack` config for Kafka Connect or MirrorMaker 2.
  TopologyKey string `json:"topologyKey"`
}

// ReadinessProbe Pod readiness checking.
type ReadinessProbe struct {

  // Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
  FailureThreshold int `json:"failureThreshold,omitempty"`

  // The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
  InitialDelaySeconds int `json:"initialDelaySeconds,omitempty"`

  // How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
  PeriodSeconds int `json:"periodSeconds,omitempty"`

  // Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
  SuccessThreshold int `json:"successThreshold,omitempty"`

  // The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
  TimeoutSeconds int `json:"timeoutSeconds,omitempty"`
}

// Requests 
type Requests struct {
}

// RequiredDuringSchedulingIgnoredDuringExecution 
type RequiredDuringSchedulingIgnoredDuringExecution struct {
  NodeSelectorTerms []*NodeSelectorTermsItems `json:"nodeSelectorTerms,omitempty"`
}

// RequiredDuringSchedulingIgnoredDuringExecutionItems 
type RequiredDuringSchedulingIgnoredDuringExecutionItems struct {
  LabelSelector *LabelSelector `json:"labelSelector,omitempty"`
  NamespaceSelector *NamespaceSelector `json:"namespaceSelector,omitempty"`
  Namespaces []string `json:"namespaces,omitempty"`
  TopologyKey string `json:"topologyKey,omitempty"`
}

// Resources CPU and memory resources to reserve.
type Resources struct {
  Claims []*ClaimsItems `json:"claims,omitempty"`
  Limits *Limits `json:"limits,omitempty"`
  Requests *Requests `json:"requests,omitempty"`
}

// SeLinuxOptions 
type SeLinuxOptions struct {
  Level string `json:"level,omitempty"`
  Role string `json:"role,omitempty"`
  Type string `json:"type,omitempty"`
  User string `json:"user,omitempty"`
}

// SeccompProfile 
type SeccompProfile struct {
  LocalhostProfile string `json:"localhostProfile,omitempty"`
  Type string `json:"type,omitempty"`
}

// SecretsItems 
type SecretsItems struct {

  // The key under which the secret value is stored in the Kubernetes Secret.
  Key string `json:"key"`

  // The name of the Kubernetes Secret containing the secret value.
  SecretName string `json:"secretName"`
}

// SecurityContext Configures pod-level security attributes and common container settings.
type SecurityContext struct {
  FsGroup int `json:"fsGroup,omitempty"`
  FsGroupChangePolicy string `json:"fsGroupChangePolicy,omitempty"`
  RunAsGroup int `json:"runAsGroup,omitempty"`
  RunAsNonRoot bool `json:"runAsNonRoot,omitempty"`
  RunAsUser int `json:"runAsUser,omitempty"`
  SeLinuxOptions *SeLinuxOptions `json:"seLinuxOptions,omitempty"`
  SeccompProfile *SeccompProfile `json:"seccompProfile,omitempty"`
  SupplementalGroups []int `json:"supplementalGroups,omitempty"`
  Sysctls []*SysctlsItems `json:"sysctls,omitempty"`
  WindowsOptions *WindowsOptions `json:"windowsOptions,omitempty"`
}

// Selector Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
type Selector struct {
}

// Service Template for Kafka Exporter `Service`.
type Service struct {

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// ServiceAccount Template for the JmxTrans service account.
type ServiceAccount struct {

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// Spec The specification of the Kafka and ZooKeeper clusters, and Topic Operator.
type Spec struct {

  // Configuration of the clients certificate authority.
  ClientsCa *ClientsCa `json:"clientsCa,omitempty"`

  // Configuration of the cluster certificate authority.
  ClusterCa *ClusterCa `json:"clusterCa,omitempty"`

  // Configuration for Cruise Control deployment. Deploys a Cruise Control instance when specified.
  CruiseControl *CruiseControl `json:"cruiseControl,omitempty"`

  // Configuration of the Entity Operator.
  EntityOperator *EntityOperator `json:"entityOperator,omitempty"`

  // As of Strimzi 0.35.0, JMXTrans is not supported anymore and this option is ignored.
  JmxTrans *JmxTrans `json:"jmxTrans,omitempty"`

  // Configuration of the Kafka cluster.
  Kafka *Kafka `json:"kafka"`

  // Configuration of the Kafka Exporter. Kafka Exporter can provide additional metrics, for example lag of consumer group at topic/partition.
  KafkaExporter *KafkaExporter `json:"kafkaExporter,omitempty"`

  // A list of time windows for maintenance tasks (that is, certificates renewal). Each time window is defined by a cron expression.
  MaintenanceTimeWindows []string `json:"maintenanceTimeWindows,omitempty"`

  // Configuration of the ZooKeeper cluster.
  Zookeeper *Zookeeper `json:"zookeeper"`
}

// StartupProbe Pod startup checking.
type StartupProbe struct {

  // Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
  FailureThreshold int `json:"failureThreshold,omitempty"`

  // The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
  InitialDelaySeconds int `json:"initialDelaySeconds,omitempty"`

  // How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
  PeriodSeconds int `json:"periodSeconds,omitempty"`

  // Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
  SuccessThreshold int `json:"successThreshold,omitempty"`

  // The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
  TimeoutSeconds int `json:"timeoutSeconds,omitempty"`
}

// Statefulset Template for ZooKeeper `StatefulSet`.
type Statefulset struct {

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`

  // PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
  PodManagementPolicy string `json:"podManagementPolicy,omitempty"`
}

// Status The status of the Kafka and ZooKeeper clusters, and Topic Operator.
type Status struct {

  // Kafka cluster Id.
  ClusterId string `json:"clusterId,omitempty"`

  // List of status conditions.
  Conditions []*ConditionsItems `json:"conditions,omitempty"`

  // List of the KafkaNodePools used by this Kafka cluster.
  KafkaNodePools []*KafkaNodePoolsItems `json:"kafkaNodePools,omitempty"`

  // Addresses of the internal and external listeners.
  Listeners []*ListenersItems `json:"listeners,omitempty"`

  // The generation of the CRD that was last reconciled by the operator.
  ObservedGeneration int `json:"observedGeneration,omitempty"`
}

// Storage Storage configuration (disk). Cannot be updated.
type Storage struct {

  // The storage class to use for dynamic volume allocation.
  Class string `json:"class,omitempty"`

  // Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
  DeleteClaim bool `json:"deleteClaim,omitempty"`

  // Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
  Id int `json:"id,omitempty"`

  // Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
  Overrides []*OverridesItems `json:"overrides,omitempty"`

  // Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
  Selector *Selector `json:"selector,omitempty"`

  // When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
  Size string `json:"size,omitempty"`

  // When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
  SizeLimit string `json:"sizeLimit,omitempty"`

  // Storage type, must be either 'ephemeral' or 'persistent-claim'.
  Type string `json:"type"`
}

// SysctlsItems 
type SysctlsItems struct {
  Name string `json:"name,omitempty"`
  Value string `json:"value,omitempty"`
}

// Template Template for JmxTrans resources.
type Template struct {

  // Template for JmxTrans container.
  Container *Container `json:"container,omitempty"`

  // Template for JmxTrans `Deployment`.
  Deployment *Deployment `json:"deployment,omitempty"`

  // Template for JmxTrans `Pods`.
  Pod *Pod `json:"pod,omitempty"`

  // Template for the JmxTrans service account.
  ServiceAccount *ServiceAccount `json:"serviceAccount,omitempty"`
}

// TlsSidecar TLS sidecar configuration.
type TlsSidecar struct {

  // The docker image for the container.
  Image string `json:"image,omitempty"`

  // Pod liveness checking.
  LivenessProbe *LivenessProbe `json:"livenessProbe,omitempty"`

  // The log level for the TLS sidecar. Default value is `notice`.
  LogLevel string `json:"logLevel,omitempty"`

  // Pod readiness checking.
  ReadinessProbe *ReadinessProbe `json:"readinessProbe,omitempty"`

  // CPU and memory resources to reserve.
  Resources *Resources `json:"resources,omitempty"`
}

// TlsSidecarContainer Template for the Cruise Control TLS sidecar container.
type TlsSidecarContainer struct {

  // Environment variables which should be applied to the container.
  Env []*EnvItems `json:"env,omitempty"`

  // Security context for the container.
  SecurityContext *SecurityContext `json:"securityContext,omitempty"`
}

// TlsTrustedCertificatesItems 
type TlsTrustedCertificatesItems struct {

  // The name of the file certificate in the Secret.
  Certificate string `json:"certificate"`

  // The name of the Secret containing the certificate.
  SecretName string `json:"secretName"`
}

// TolerationsItems 
type TolerationsItems struct {
  Effect string `json:"effect,omitempty"`
  Key string `json:"key,omitempty"`
  Operator string `json:"operator,omitempty"`
  TolerationSeconds int `json:"tolerationSeconds,omitempty"`
  Value string `json:"value,omitempty"`
}

// TopicOperator Configuration of the Topic Operator.
type TopicOperator struct {

  // The image to use for the Topic Operator.
  Image string `json:"image,omitempty"`

  // JVM Options for pods.
  JvmOptions *JvmOptions `json:"jvmOptions,omitempty"`

  // Pod liveness checking.
  LivenessProbe *LivenessProbe `json:"livenessProbe,omitempty"`

  // Logging configuration.
  Logging *Logging `json:"logging,omitempty"`

  // Pod readiness checking.
  ReadinessProbe *ReadinessProbe `json:"readinessProbe,omitempty"`

  // Interval between periodic reconciliations.
  ReconciliationIntervalSeconds int `json:"reconciliationIntervalSeconds,omitempty"`

  // CPU and memory resources to reserve.
  Resources *Resources `json:"resources,omitempty"`

  // Pod startup checking.
  StartupProbe *StartupProbe `json:"startupProbe,omitempty"`

  // The number of attempts at getting topic metadata.
  TopicMetadataMaxAttempts int `json:"topicMetadataMaxAttempts,omitempty"`

  // The namespace the Topic Operator should watch.
  WatchedNamespace string `json:"watchedNamespace,omitempty"`

  // Timeout for the ZooKeeper session.
  ZookeeperSessionTimeoutSeconds int `json:"zookeeperSessionTimeoutSeconds,omitempty"`
}

// TopicOperatorContainer Template for the Entity Topic Operator container.
type TopicOperatorContainer struct {

  // Environment variables which should be applied to the container.
  Env []*EnvItems `json:"env,omitempty"`

  // Security context for the container.
  SecurityContext *SecurityContext `json:"securityContext,omitempty"`
}

// TopicOperatorRoleBinding Template for the Entity Topic Operator RoleBinding.
type TopicOperatorRoleBinding struct {

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// TopologySpreadConstraintsItems 
type TopologySpreadConstraintsItems struct {
  LabelSelector *LabelSelector `json:"labelSelector,omitempty"`
  MatchLabelKeys []string `json:"matchLabelKeys,omitempty"`
  MaxSkew int `json:"maxSkew,omitempty"`
  MinDomains int `json:"minDomains,omitempty"`
  NodeAffinityPolicy string `json:"nodeAffinityPolicy,omitempty"`
  NodeTaintsPolicy string `json:"nodeTaintsPolicy,omitempty"`
  TopologyKey string `json:"topologyKey,omitempty"`
  WhenUnsatisfiable string `json:"whenUnsatisfiable,omitempty"`
}

// UserOperator Configuration of the User Operator.
type UserOperator struct {

  // The image to use for the User Operator.
  Image string `json:"image,omitempty"`

  // JVM Options for pods.
  JvmOptions *JvmOptions `json:"jvmOptions,omitempty"`

  // Pod liveness checking.
  LivenessProbe *LivenessProbe `json:"livenessProbe,omitempty"`

  // Logging configuration.
  Logging *Logging `json:"logging,omitempty"`

  // Pod readiness checking.
  ReadinessProbe *ReadinessProbe `json:"readinessProbe,omitempty"`

  // Interval between periodic reconciliations.
  ReconciliationIntervalSeconds int `json:"reconciliationIntervalSeconds,omitempty"`

  // CPU and memory resources to reserve.
  Resources *Resources `json:"resources,omitempty"`

  // The prefix that will be added to the KafkaUser name to be used as the Secret name.
  SecretPrefix string `json:"secretPrefix,omitempty"`

  // The namespace the User Operator should watch.
  WatchedNamespace string `json:"watchedNamespace,omitempty"`

  // Timeout for the ZooKeeper session.
  ZookeeperSessionTimeoutSeconds int `json:"zookeeperSessionTimeoutSeconds,omitempty"`
}

// UserOperatorContainer Template for the Entity User Operator container.
type UserOperatorContainer struct {

  // Environment variables which should be applied to the container.
  Env []*EnvItems `json:"env,omitempty"`

  // Security context for the container.
  SecurityContext *SecurityContext `json:"securityContext,omitempty"`
}

// UserOperatorRoleBinding Template for the Entity Topic Operator RoleBinding.
type UserOperatorRoleBinding struct {

  // Metadata applied to the resource.
  Metadata *Metadata `json:"metadata,omitempty"`
}

// ValueFrom `ConfigMap` entry where the logging configuration is stored. 
type ValueFrom struct {

  // Reference to the key in the ConfigMap containing the configuration.
  ConfigMapKeyRef *ConfigMapKeyRef `json:"configMapKeyRef,omitempty"`
}

// VolumesItems 
type VolumesItems struct {

  // The storage class to use for dynamic volume allocation.
  Class string `json:"class,omitempty"`

  // Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
  DeleteClaim bool `json:"deleteClaim,omitempty"`

  // Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
  Id int `json:"id,omitempty"`

  // Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
  Overrides []*OverridesItems `json:"overrides,omitempty"`

  // Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
  Selector *Selector `json:"selector,omitempty"`

  // When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
  Size string `json:"size,omitempty"`

  // When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
  SizeLimit string `json:"sizeLimit,omitempty"`

  // Storage type, must be either 'ephemeral' or 'persistent-claim'.
  Type string `json:"type"`
}

// WindowsOptions 
type WindowsOptions struct {
  GmsaCredentialSpec string `json:"gmsaCredentialSpec,omitempty"`
  GmsaCredentialSpecName string `json:"gmsaCredentialSpecName,omitempty"`
  HostProcess bool `json:"hostProcess,omitempty"`
  RunAsUserName string `json:"runAsUserName,omitempty"`
}

// XX A map of -XX options to the JVM.
type XX struct {
}

// Zookeeper Configuration of the ZooKeeper cluster.
type Zookeeper struct {

  // The ZooKeeper broker config. Properties with the following prefixes cannot be set: server., dataDir, dataLogDir, clientPort, authProvider, quorum.auth, requireClientAuthScheme, snapshot.trust.empty, standaloneEnabled, reconfigEnabled, 4lw.commands.whitelist, secureClientPort, ssl., serverCnxnFactory, sslQuorum (with the exception of: ssl.protocol, ssl.quorum.protocol, ssl.enabledProtocols, ssl.quorum.enabledProtocols, ssl.ciphersuites, ssl.quorum.ciphersuites, ssl.hostnameVerification, ssl.quorum.hostnameVerification).
  Config *Config `json:"config,omitempty"`

  // The docker image for the pods.
  Image string `json:"image,omitempty"`

  // JMX Options for Zookeeper nodes.
  JmxOptions *JmxOptions `json:"jmxOptions,omitempty"`

  // JVM Options for pods.
  JvmOptions *JvmOptions `json:"jvmOptions,omitempty"`

  // Pod liveness checking.
  LivenessProbe *LivenessProbe `json:"livenessProbe,omitempty"`

  // Logging configuration for ZooKeeper.
  Logging *Logging `json:"logging,omitempty"`

  // Metrics configuration.
  MetricsConfig *MetricsConfig `json:"metricsConfig,omitempty"`

  // Pod readiness checking.
  ReadinessProbe *ReadinessProbe `json:"readinessProbe,omitempty"`

  // The number of pods in the cluster.
  Replicas int `json:"replicas"`

  // CPU and memory resources to reserve.
  Resources *Resources `json:"resources,omitempty"`

  // Storage configuration (disk). Cannot be updated.
  Storage *Storage `json:"storage"`

  // Template for ZooKeeper cluster resources. The template allows users to specify how the Kubernetes resources are generated.
  Template *Template `json:"template,omitempty"`
}

// ZookeeperContainer Template for the ZooKeeper container.
type ZookeeperContainer struct {

  // Environment variables which should be applied to the container.
  Env []*EnvItems `json:"env,omitempty"`

  // Security context for the container.
  SecurityContext *SecurityContext `json:"securityContext,omitempty"`
}

func (strct *Authentication) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Authentication) UnmarshalJSON(b []byte) error {
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        }
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *Authorization) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "allowOnError" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"allowOnError\": ")
	if tmp, err := json.Marshal(strct.AllowOnError); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "authorizerClass" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"authorizerClass\": ")
	if tmp, err := json.Marshal(strct.AuthorizerClass); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "clientId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"clientId\": ")
	if tmp, err := json.Marshal(strct.ClientId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "connectTimeoutSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"connectTimeoutSeconds\": ")
	if tmp, err := json.Marshal(strct.ConnectTimeoutSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "delegateToKafkaAcls" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"delegateToKafkaAcls\": ")
	if tmp, err := json.Marshal(strct.DelegateToKafkaAcls); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "disableTlsHostnameVerification" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"disableTlsHostnameVerification\": ")
	if tmp, err := json.Marshal(strct.DisableTlsHostnameVerification); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "enableMetrics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"enableMetrics\": ")
	if tmp, err := json.Marshal(strct.EnableMetrics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "expireAfterMs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"expireAfterMs\": ")
	if tmp, err := json.Marshal(strct.ExpireAfterMs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "grantsAlwaysLatest" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"grantsAlwaysLatest\": ")
	if tmp, err := json.Marshal(strct.GrantsAlwaysLatest); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "grantsGcPeriodSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"grantsGcPeriodSeconds\": ")
	if tmp, err := json.Marshal(strct.GrantsGcPeriodSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "grantsMaxIdleTimeSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"grantsMaxIdleTimeSeconds\": ")
	if tmp, err := json.Marshal(strct.GrantsMaxIdleTimeSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "grantsRefreshPeriodSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"grantsRefreshPeriodSeconds\": ")
	if tmp, err := json.Marshal(strct.GrantsRefreshPeriodSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "grantsRefreshPoolSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"grantsRefreshPoolSize\": ")
	if tmp, err := json.Marshal(strct.GrantsRefreshPoolSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "httpRetries" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"httpRetries\": ")
	if tmp, err := json.Marshal(strct.HttpRetries); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "initialCacheCapacity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"initialCacheCapacity\": ")
	if tmp, err := json.Marshal(strct.InitialCacheCapacity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maximumCacheSize" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maximumCacheSize\": ")
	if tmp, err := json.Marshal(strct.MaximumCacheSize); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "readTimeoutSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"readTimeoutSeconds\": ")
	if tmp, err := json.Marshal(strct.ReadTimeoutSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "superUsers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"superUsers\": ")
	if tmp, err := json.Marshal(strct.SuperUsers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "supportsAdminApi" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"supportsAdminApi\": ")
	if tmp, err := json.Marshal(strct.SupportsAdminApi); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "tlsTrustedCertificates" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"tlsTrustedCertificates\": ")
	if tmp, err := json.Marshal(strct.TlsTrustedCertificates); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "tokenEndpointUri" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"tokenEndpointUri\": ")
	if tmp, err := json.Marshal(strct.TokenEndpointUri); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Authorization) UnmarshalJSON(b []byte) error {
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "allowOnError":
            if err := json.Unmarshal([]byte(v), &strct.AllowOnError); err != nil {
                return err
             }
        case "authorizerClass":
            if err := json.Unmarshal([]byte(v), &strct.AuthorizerClass); err != nil {
                return err
             }
        case "clientId":
            if err := json.Unmarshal([]byte(v), &strct.ClientId); err != nil {
                return err
             }
        case "connectTimeoutSeconds":
            if err := json.Unmarshal([]byte(v), &strct.ConnectTimeoutSeconds); err != nil {
                return err
             }
        case "delegateToKafkaAcls":
            if err := json.Unmarshal([]byte(v), &strct.DelegateToKafkaAcls); err != nil {
                return err
             }
        case "disableTlsHostnameVerification":
            if err := json.Unmarshal([]byte(v), &strct.DisableTlsHostnameVerification); err != nil {
                return err
             }
        case "enableMetrics":
            if err := json.Unmarshal([]byte(v), &strct.EnableMetrics); err != nil {
                return err
             }
        case "expireAfterMs":
            if err := json.Unmarshal([]byte(v), &strct.ExpireAfterMs); err != nil {
                return err
             }
        case "grantsAlwaysLatest":
            if err := json.Unmarshal([]byte(v), &strct.GrantsAlwaysLatest); err != nil {
                return err
             }
        case "grantsGcPeriodSeconds":
            if err := json.Unmarshal([]byte(v), &strct.GrantsGcPeriodSeconds); err != nil {
                return err
             }
        case "grantsMaxIdleTimeSeconds":
            if err := json.Unmarshal([]byte(v), &strct.GrantsMaxIdleTimeSeconds); err != nil {
                return err
             }
        case "grantsRefreshPeriodSeconds":
            if err := json.Unmarshal([]byte(v), &strct.GrantsRefreshPeriodSeconds); err != nil {
                return err
             }
        case "grantsRefreshPoolSize":
            if err := json.Unmarshal([]byte(v), &strct.GrantsRefreshPoolSize); err != nil {
                return err
             }
        case "httpRetries":
            if err := json.Unmarshal([]byte(v), &strct.HttpRetries); err != nil {
                return err
             }
        case "initialCacheCapacity":
            if err := json.Unmarshal([]byte(v), &strct.InitialCacheCapacity); err != nil {
                return err
             }
        case "maximumCacheSize":
            if err := json.Unmarshal([]byte(v), &strct.MaximumCacheSize); err != nil {
                return err
             }
        case "readTimeoutSeconds":
            if err := json.Unmarshal([]byte(v), &strct.ReadTimeoutSeconds); err != nil {
                return err
             }
        case "superUsers":
            if err := json.Unmarshal([]byte(v), &strct.SuperUsers); err != nil {
                return err
             }
        case "supportsAdminApi":
            if err := json.Unmarshal([]byte(v), &strct.SupportsAdminApi); err != nil {
                return err
             }
        case "tlsTrustedCertificates":
            if err := json.Unmarshal([]byte(v), &strct.TlsTrustedCertificates); err != nil {
                return err
             }
        case "tokenEndpointUri":
            if err := json.Unmarshal([]byte(v), &strct.TokenEndpointUri); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        case "url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
        }
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *BrokerCertChainAndKey) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Certificate" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "certificate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"certificate\": ")
	if tmp, err := json.Marshal(strct.Certificate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SecretName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "secretName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"secretName\": ")
	if tmp, err := json.Marshal(strct.SecretName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BrokerCertChainAndKey) UnmarshalJSON(b []byte) error {
    certificateReceived := false
    keyReceived := false
    secretNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "certificate":
            if err := json.Unmarshal([]byte(v), &strct.Certificate); err != nil {
                return err
             }
            certificateReceived = true
        case "key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            keyReceived = true
        case "secretName":
            if err := json.Unmarshal([]byte(v), &strct.SecretName); err != nil {
                return err
             }
            secretNameReceived = true
        }
    }
    // check if certificate (a required property) was received
    if !certificateReceived {
        return errors.New("\"certificate\" is required but was not present")
    }
    // check if key (a required property) was received
    if !keyReceived {
        return errors.New("\"key\" is required but was not present")
    }
    // check if secretName (a required property) was received
    if !secretNameReceived {
        return errors.New("\"secretName\" is required but was not present")
    }
    return nil
}

func (strct *BrokersItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "advertisedHost" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"advertisedHost\": ")
	if tmp, err := json.Marshal(strct.AdvertisedHost); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "advertisedPort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"advertisedPort\": ")
	if tmp, err := json.Marshal(strct.AdvertisedPort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "annotations" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"annotations\": ")
	if tmp, err := json.Marshal(strct.Annotations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Broker" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "broker" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"broker\": ")
	if tmp, err := json.Marshal(strct.Broker); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "labels" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"labels\": ")
	if tmp, err := json.Marshal(strct.Labels); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "loadBalancerIP" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"loadBalancerIP\": ")
	if tmp, err := json.Marshal(strct.LoadBalancerIP); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "nodePort" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"nodePort\": ")
	if tmp, err := json.Marshal(strct.NodePort); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BrokersItems) UnmarshalJSON(b []byte) error {
    brokerReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "advertisedHost":
            if err := json.Unmarshal([]byte(v), &strct.AdvertisedHost); err != nil {
                return err
             }
        case "advertisedPort":
            if err := json.Unmarshal([]byte(v), &strct.AdvertisedPort); err != nil {
                return err
             }
        case "annotations":
            if err := json.Unmarshal([]byte(v), &strct.Annotations); err != nil {
                return err
             }
        case "broker":
            if err := json.Unmarshal([]byte(v), &strct.Broker); err != nil {
                return err
             }
            brokerReceived = true
        case "host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
        case "labels":
            if err := json.Unmarshal([]byte(v), &strct.Labels); err != nil {
                return err
             }
        case "loadBalancerIP":
            if err := json.Unmarshal([]byte(v), &strct.LoadBalancerIP); err != nil {
                return err
             }
        case "nodePort":
            if err := json.Unmarshal([]byte(v), &strct.NodePort); err != nil {
                return err
             }
        }
    }
    // check if broker (a required property) was received
    if !brokerReceived {
        return errors.New("\"broker\" is required but was not present")
    }
    return nil
}

func (strct *ClientSecret) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SecretName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "secretName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"secretName\": ")
	if tmp, err := json.Marshal(strct.SecretName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ClientSecret) UnmarshalJSON(b []byte) error {
    keyReceived := false
    secretNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            keyReceived = true
        case "secretName":
            if err := json.Unmarshal([]byte(v), &strct.SecretName); err != nil {
                return err
             }
            secretNameReceived = true
        }
    }
    // check if key (a required property) was received
    if !keyReceived {
        return errors.New("\"key\" is required but was not present")
    }
    // check if secretName (a required property) was received
    if !secretNameReceived {
        return errors.New("\"secretName\" is required but was not present")
    }
    return nil
}

func (strct *JmxTrans) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "image" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"image\": ")
	if tmp, err := json.Marshal(strct.Image); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "KafkaQueries" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "kafkaQueries" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"kafkaQueries\": ")
	if tmp, err := json.Marshal(strct.KafkaQueries); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "logLevel" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"logLevel\": ")
	if tmp, err := json.Marshal(strct.LogLevel); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "OutputDefinitions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "outputDefinitions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"outputDefinitions\": ")
	if tmp, err := json.Marshal(strct.OutputDefinitions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "resources" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"resources\": ")
	if tmp, err := json.Marshal(strct.Resources); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "template" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"template\": ")
	if tmp, err := json.Marshal(strct.Template); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *JmxTrans) UnmarshalJSON(b []byte) error {
    kafkaQueriesReceived := false
    outputDefinitionsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "image":
            if err := json.Unmarshal([]byte(v), &strct.Image); err != nil {
                return err
             }
        case "kafkaQueries":
            if err := json.Unmarshal([]byte(v), &strct.KafkaQueries); err != nil {
                return err
             }
            kafkaQueriesReceived = true
        case "logLevel":
            if err := json.Unmarshal([]byte(v), &strct.LogLevel); err != nil {
                return err
             }
        case "outputDefinitions":
            if err := json.Unmarshal([]byte(v), &strct.OutputDefinitions); err != nil {
                return err
             }
            outputDefinitionsReceived = true
        case "resources":
            if err := json.Unmarshal([]byte(v), &strct.Resources); err != nil {
                return err
             }
        case "template":
            if err := json.Unmarshal([]byte(v), &strct.Template); err != nil {
                return err
             }
        }
    }
    // check if kafkaQueries (a required property) was received
    if !kafkaQueriesReceived {
        return errors.New("\"kafkaQueries\" is required but was not present")
    }
    // check if outputDefinitions (a required property) was received
    if !outputDefinitionsReceived {
        return errors.New("\"outputDefinitions\" is required but was not present")
    }
    return nil
}

func (strct *KafkaQueriesItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Attributes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "attributes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"attributes\": ")
	if tmp, err := json.Marshal(strct.Attributes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Outputs" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "outputs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"outputs\": ")
	if tmp, err := json.Marshal(strct.Outputs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TargetMBean" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "targetMBean" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"targetMBean\": ")
	if tmp, err := json.Marshal(strct.TargetMBean); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *KafkaQueriesItems) UnmarshalJSON(b []byte) error {
    attributesReceived := false
    outputsReceived := false
    targetMBeanReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "attributes":
            if err := json.Unmarshal([]byte(v), &strct.Attributes); err != nil {
                return err
             }
            attributesReceived = true
        case "outputs":
            if err := json.Unmarshal([]byte(v), &strct.Outputs); err != nil {
                return err
             }
            outputsReceived = true
        case "targetMBean":
            if err := json.Unmarshal([]byte(v), &strct.TargetMBean); err != nil {
                return err
             }
            targetMBeanReceived = true
        }
    }
    // check if attributes (a required property) was received
    if !attributesReceived {
        return errors.New("\"attributes\" is required but was not present")
    }
    // check if outputs (a required property) was received
    if !outputsReceived {
        return errors.New("\"outputs\" is required but was not present")
    }
    // check if targetMBean (a required property) was received
    if !targetMBeanReceived {
        return errors.New("\"targetMBean\" is required but was not present")
    }
    return nil
}

func (strct *Logging) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "loggers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"loggers\": ")
	if tmp, err := json.Marshal(strct.Loggers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "valueFrom" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"valueFrom\": ")
	if tmp, err := json.Marshal(strct.ValueFrom); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Logging) UnmarshalJSON(b []byte) error {
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "loggers":
            if err := json.Unmarshal([]byte(v), &strct.Loggers); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        case "valueFrom":
            if err := json.Unmarshal([]byte(v), &strct.ValueFrom); err != nil {
                return err
             }
        }
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *MetricsConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ValueFrom" field is required
    if strct.ValueFrom == nil {
        return nil, errors.New("valueFrom is a required field")
    }
    // Marshal the "valueFrom" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"valueFrom\": ")
	if tmp, err := json.Marshal(strct.ValueFrom); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MetricsConfig) UnmarshalJSON(b []byte) error {
    typeReceived := false
    valueFromReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        case "valueFrom":
            if err := json.Unmarshal([]byte(v), &strct.ValueFrom); err != nil {
                return err
             }
            valueFromReceived = true
        }
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    // check if valueFrom (a required property) was received
    if !valueFromReceived {
        return errors.New("\"valueFrom\" is required but was not present")
    }
    return nil
}

func (strct *OutputDefinitionsItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "flushDelayInSeconds" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"flushDelayInSeconds\": ")
	if tmp, err := json.Marshal(strct.FlushDelayInSeconds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "OutputType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "outputType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"outputType\": ")
	if tmp, err := json.Marshal(strct.OutputType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "port" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"port\": ")
	if tmp, err := json.Marshal(strct.Port); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "typeNames" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"typeNames\": ")
	if tmp, err := json.Marshal(strct.TypeNames); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OutputDefinitionsItems) UnmarshalJSON(b []byte) error {
    nameReceived := false
    outputTypeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "flushDelayInSeconds":
            if err := json.Unmarshal([]byte(v), &strct.FlushDelayInSeconds); err != nil {
                return err
             }
        case "host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        case "outputType":
            if err := json.Unmarshal([]byte(v), &strct.OutputType); err != nil {
                return err
             }
            outputTypeReceived = true
        case "port":
            if err := json.Unmarshal([]byte(v), &strct.Port); err != nil {
                return err
             }
        case "typeNames":
            if err := json.Unmarshal([]byte(v), &strct.TypeNames); err != nil {
                return err
             }
        }
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    // check if outputType (a required property) was received
    if !outputTypeReceived {
        return errors.New("\"outputType\" is required but was not present")
    }
    return nil
}

func (strct *Rack) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "TopologyKey" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "topologyKey" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"topologyKey\": ")
	if tmp, err := json.Marshal(strct.TopologyKey); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Rack) UnmarshalJSON(b []byte) error {
    topologyKeyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "topologyKey":
            if err := json.Unmarshal([]byte(v), &strct.TopologyKey); err != nil {
                return err
             }
            topologyKeyReceived = true
        }
    }
    // check if topologyKey (a required property) was received
    if !topologyKeyReceived {
        return errors.New("\"topologyKey\" is required but was not present")
    }
    return nil
}

func (strct *SecretsItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Key" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "key" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"key\": ")
	if tmp, err := json.Marshal(strct.Key); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SecretName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "secretName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"secretName\": ")
	if tmp, err := json.Marshal(strct.SecretName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SecretsItems) UnmarshalJSON(b []byte) error {
    keyReceived := false
    secretNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "key":
            if err := json.Unmarshal([]byte(v), &strct.Key); err != nil {
                return err
             }
            keyReceived = true
        case "secretName":
            if err := json.Unmarshal([]byte(v), &strct.SecretName); err != nil {
                return err
             }
            secretNameReceived = true
        }
    }
    // check if key (a required property) was received
    if !keyReceived {
        return errors.New("\"key\" is required but was not present")
    }
    // check if secretName (a required property) was received
    if !secretNameReceived {
        return errors.New("\"secretName\" is required but was not present")
    }
    return nil
}

func (strct *Spec) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "clientsCa" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"clientsCa\": ")
	if tmp, err := json.Marshal(strct.ClientsCa); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "clusterCa" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"clusterCa\": ")
	if tmp, err := json.Marshal(strct.ClusterCa); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "cruiseControl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"cruiseControl\": ")
	if tmp, err := json.Marshal(strct.CruiseControl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "entityOperator" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"entityOperator\": ")
	if tmp, err := json.Marshal(strct.EntityOperator); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "jmxTrans" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"jmxTrans\": ")
	if tmp, err := json.Marshal(strct.JmxTrans); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Kafka" field is required
    if strct.Kafka == nil {
        return nil, errors.New("kafka is a required field")
    }
    // Marshal the "kafka" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"kafka\": ")
	if tmp, err := json.Marshal(strct.Kafka); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "kafkaExporter" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"kafkaExporter\": ")
	if tmp, err := json.Marshal(strct.KafkaExporter); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maintenanceTimeWindows" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maintenanceTimeWindows\": ")
	if tmp, err := json.Marshal(strct.MaintenanceTimeWindows); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Zookeeper" field is required
    if strct.Zookeeper == nil {
        return nil, errors.New("zookeeper is a required field")
    }
    // Marshal the "zookeeper" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"zookeeper\": ")
	if tmp, err := json.Marshal(strct.Zookeeper); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Spec) UnmarshalJSON(b []byte) error {
    kafkaReceived := false
    zookeeperReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "clientsCa":
            if err := json.Unmarshal([]byte(v), &strct.ClientsCa); err != nil {
                return err
             }
        case "clusterCa":
            if err := json.Unmarshal([]byte(v), &strct.ClusterCa); err != nil {
                return err
             }
        case "cruiseControl":
            if err := json.Unmarshal([]byte(v), &strct.CruiseControl); err != nil {
                return err
             }
        case "entityOperator":
            if err := json.Unmarshal([]byte(v), &strct.EntityOperator); err != nil {
                return err
             }
        case "jmxTrans":
            if err := json.Unmarshal([]byte(v), &strct.JmxTrans); err != nil {
                return err
             }
        case "kafka":
            if err := json.Unmarshal([]byte(v), &strct.Kafka); err != nil {
                return err
             }
            kafkaReceived = true
        case "kafkaExporter":
            if err := json.Unmarshal([]byte(v), &strct.KafkaExporter); err != nil {
                return err
             }
        case "maintenanceTimeWindows":
            if err := json.Unmarshal([]byte(v), &strct.MaintenanceTimeWindows); err != nil {
                return err
             }
        case "zookeeper":
            if err := json.Unmarshal([]byte(v), &strct.Zookeeper); err != nil {
                return err
             }
            zookeeperReceived = true
        }
    }
    // check if kafka (a required property) was received
    if !kafkaReceived {
        return errors.New("\"kafka\" is required but was not present")
    }
    // check if zookeeper (a required property) was received
    if !zookeeperReceived {
        return errors.New("\"zookeeper\" is required but was not present")
    }
    return nil
}

func (strct *Storage) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "class" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"class\": ")
	if tmp, err := json.Marshal(strct.Class); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "deleteClaim" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"deleteClaim\": ")
	if tmp, err := json.Marshal(strct.DeleteClaim); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "overrides" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"overrides\": ")
	if tmp, err := json.Marshal(strct.Overrides); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "selector" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"selector\": ")
	if tmp, err := json.Marshal(strct.Selector); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "size" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"size\": ")
	if tmp, err := json.Marshal(strct.Size); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sizeLimit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"sizeLimit\": ")
	if tmp, err := json.Marshal(strct.SizeLimit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Storage) UnmarshalJSON(b []byte) error {
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "class":
            if err := json.Unmarshal([]byte(v), &strct.Class); err != nil {
                return err
             }
        case "deleteClaim":
            if err := json.Unmarshal([]byte(v), &strct.DeleteClaim); err != nil {
                return err
             }
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "overrides":
            if err := json.Unmarshal([]byte(v), &strct.Overrides); err != nil {
                return err
             }
        case "selector":
            if err := json.Unmarshal([]byte(v), &strct.Selector); err != nil {
                return err
             }
        case "size":
            if err := json.Unmarshal([]byte(v), &strct.Size); err != nil {
                return err
             }
        case "sizeLimit":
            if err := json.Unmarshal([]byte(v), &strct.SizeLimit); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        }
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *TlsTrustedCertificatesItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Certificate" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "certificate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"certificate\": ")
	if tmp, err := json.Marshal(strct.Certificate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SecretName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "secretName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"secretName\": ")
	if tmp, err := json.Marshal(strct.SecretName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TlsTrustedCertificatesItems) UnmarshalJSON(b []byte) error {
    certificateReceived := false
    secretNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "certificate":
            if err := json.Unmarshal([]byte(v), &strct.Certificate); err != nil {
                return err
             }
            certificateReceived = true
        case "secretName":
            if err := json.Unmarshal([]byte(v), &strct.SecretName); err != nil {
                return err
             }
            secretNameReceived = true
        }
    }
    // check if certificate (a required property) was received
    if !certificateReceived {
        return errors.New("\"certificate\" is required but was not present")
    }
    // check if secretName (a required property) was received
    if !secretNameReceived {
        return errors.New("\"secretName\" is required but was not present")
    }
    return nil
}

func (strct *VolumesItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "class" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"class\": ")
	if tmp, err := json.Marshal(strct.Class); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "deleteClaim" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"deleteClaim\": ")
	if tmp, err := json.Marshal(strct.DeleteClaim); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "overrides" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"overrides\": ")
	if tmp, err := json.Marshal(strct.Overrides); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "selector" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"selector\": ")
	if tmp, err := json.Marshal(strct.Selector); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "size" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"size\": ")
	if tmp, err := json.Marshal(strct.Size); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sizeLimit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"sizeLimit\": ")
	if tmp, err := json.Marshal(strct.SizeLimit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VolumesItems) UnmarshalJSON(b []byte) error {
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "class":
            if err := json.Unmarshal([]byte(v), &strct.Class); err != nil {
                return err
             }
        case "deleteClaim":
            if err := json.Unmarshal([]byte(v), &strct.DeleteClaim); err != nil {
                return err
             }
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
        case "overrides":
            if err := json.Unmarshal([]byte(v), &strct.Overrides); err != nil {
                return err
             }
        case "selector":
            if err := json.Unmarshal([]byte(v), &strct.Selector); err != nil {
                return err
             }
        case "size":
            if err := json.Unmarshal([]byte(v), &strct.Size); err != nil {
                return err
             }
        case "sizeLimit":
            if err := json.Unmarshal([]byte(v), &strct.SizeLimit); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        }
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *Zookeeper) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "config" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"config\": ")
	if tmp, err := json.Marshal(strct.Config); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "image" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"image\": ")
	if tmp, err := json.Marshal(strct.Image); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "jmxOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"jmxOptions\": ")
	if tmp, err := json.Marshal(strct.JmxOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "jvmOptions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"jvmOptions\": ")
	if tmp, err := json.Marshal(strct.JvmOptions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "livenessProbe" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"livenessProbe\": ")
	if tmp, err := json.Marshal(strct.LivenessProbe); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "logging" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"logging\": ")
	if tmp, err := json.Marshal(strct.Logging); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "metricsConfig" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"metricsConfig\": ")
	if tmp, err := json.Marshal(strct.MetricsConfig); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "readinessProbe" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"readinessProbe\": ")
	if tmp, err := json.Marshal(strct.ReadinessProbe); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Replicas" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "replicas" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"replicas\": ")
	if tmp, err := json.Marshal(strct.Replicas); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "resources" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"resources\": ")
	if tmp, err := json.Marshal(strct.Resources); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Storage" field is required
    if strct.Storage == nil {
        return nil, errors.New("storage is a required field")
    }
    // Marshal the "storage" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"storage\": ")
	if tmp, err := json.Marshal(strct.Storage); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "template" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"template\": ")
	if tmp, err := json.Marshal(strct.Template); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Zookeeper) UnmarshalJSON(b []byte) error {
    replicasReceived := false
    storageReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "config":
            if err := json.Unmarshal([]byte(v), &strct.Config); err != nil {
                return err
             }
        case "image":
            if err := json.Unmarshal([]byte(v), &strct.Image); err != nil {
                return err
             }
        case "jmxOptions":
            if err := json.Unmarshal([]byte(v), &strct.JmxOptions); err != nil {
                return err
             }
        case "jvmOptions":
            if err := json.Unmarshal([]byte(v), &strct.JvmOptions); err != nil {
                return err
             }
        case "livenessProbe":
            if err := json.Unmarshal([]byte(v), &strct.LivenessProbe); err != nil {
                return err
             }
        case "logging":
            if err := json.Unmarshal([]byte(v), &strct.Logging); err != nil {
                return err
             }
        case "metricsConfig":
            if err := json.Unmarshal([]byte(v), &strct.MetricsConfig); err != nil {
                return err
             }
        case "readinessProbe":
            if err := json.Unmarshal([]byte(v), &strct.ReadinessProbe); err != nil {
                return err
             }
        case "replicas":
            if err := json.Unmarshal([]byte(v), &strct.Replicas); err != nil {
                return err
             }
            replicasReceived = true
        case "resources":
            if err := json.Unmarshal([]byte(v), &strct.Resources); err != nil {
                return err
             }
        case "storage":
            if err := json.Unmarshal([]byte(v), &strct.Storage); err != nil {
                return err
             }
            storageReceived = true
        case "template":
            if err := json.Unmarshal([]byte(v), &strct.Template); err != nil {
                return err
             }
        }
    }
    // check if replicas (a required property) was received
    if !replicasReceived {
        return errors.New("\"replicas\" is required but was not present")
    }
    // check if storage (a required property) was received
    if !storageReceived {
        return errors.New("\"storage\" is required but was not present")
    }
    return nil
}
